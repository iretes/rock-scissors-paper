[
  {
    "objectID": "notebooks/long_range_simulations.html",
    "href": "notebooks/long_range_simulations.html",
    "title": "Long range dispersal model",
    "section": "",
    "text": "This notebook simulates the evolution of a three-species system with long-range dispersal, treating individuals as gas molecules with interactions occurring between any pair."
  },
  {
    "objectID": "notebooks/long_range_simulations.html#theoretical-framework",
    "href": "notebooks/long_range_simulations.html#theoretical-framework",
    "title": "Long range dispersal model",
    "section": "Theoretical framework",
    "text": "Theoretical framework\nFinite population size\nLet’s consider a model world that has \\(N\\) available sites. The sites are occupied by three species, namely species \\(r\\) (rock), \\(s\\) (scissors) and \\(p\\) (paper), which occur in the proportions \\(n_r\\) , \\(n_s\\) and \\(n_p\\) (with \\(n_r + n_s + n_p = 1\\)). Two sites are chosen at each time-step. The occupant of the first replicates into the second with a given probability - individual of species \\(r\\) can invade a species \\(s\\) with probability \\(P_r\\), a species \\(s\\) invades a species \\(p\\) with probability \\(P_s\\), a species \\(p\\) invades a species \\(r\\) with probability \\(P_p\\) and all other invasion probabilities are zero. This dynamic may represent individuals competing for food: the winner consumes the food and gains enough resources to reproduce asexually, while the loser dies.\nContinuous-time model\nIn the limit of large \\(N\\), the rate of change of species population density is given by the mean-field equations:\n\\[\\begin{cases}\n\\frac{\\partial n_r}{\\partial t}=n_r\\cdot (n_s\\cdot P_r - n_p \\cdot P_p)\\\\\n\\frac{\\partial n_s}{\\partial t}=n_s\\cdot (n_p\\cdot P_s - n_r \\cdot P_r)\\\\\n\\frac{\\partial n_p}{\\partial t}=n_p\\cdot (n_r\\cdot P_p - n_s \\cdot P_s)\\\\\n\\end{cases}\\]\nwhere the system dynamic is approximated considering the average effect of interactions rather than tracking every specific interaction (hence the term mean-field).\nFor example, in the first equation, \\(n_s\\cdot P_r\\) represents the rate at which the rock species increases due to its successful invasion of the scissors species, while \\(n_p\\cdot P_p\\) represents the rate at which the rock species decreases due to the successful invasion of the paper species. The difference between these terms is then multiplied by the population density of the rock species to ensure that the rate of change is properly scaled according to the availability of species \\(r\\). Similar considerations apply to the other equations.\nNote that in these equations a unit of time \\(t\\) is \\(N\\) individual time-steps, which we refer to as an epoch.\nFixed-point analysis\nTrivial fixed points of the system are (\\(n_r=0, n_s=0, n_p=1\\)), (\\(n_r=0, n_s=1, n_p=0\\)) and (\\(n_r=1, n_s=0, n_p=0\\)).\nThe non-trivial fixed point is obtained by setting the rates of change to zero:\n\\[\\begin{cases}\n\\frac{\\partial n_r}{\\partial t}=n_r\\cdot (n_s\\cdot P_r - n_p \\cdot P_p)=0 \\implies n_p = \\frac{n_s\\cdot P_r}{P_p}&\\text{(1)}\\\\\n\\frac{\\partial n_s}{\\partial t}=n_s\\cdot (n_p\\cdot P_s - n_r \\cdot P_r)=0 \\implies n_r = \\frac{n_p\\cdot P_s}{P_r}&\\text{(2)}\\\\\nn_r+n_s+n_p=1 \\implies n_s = 1-n_p-n_r&\\text{(3)}\\\\\n\\end{cases}\\]\n\\[\\implies\\]\n\\[\\begin{cases}\nn_r = \\frac{n_s \\cdot \\cancel{P_r}\\cdot P_s}{P_p\\cdot \\cancel{P_r}}&\\text{(4), substituting (1) into (2)}\\\\\nn_s = 1-\\frac{n_s\\cdot P_r}{P_p}-nr&\\text{(5), substituting (1) into (3)}\\\\\n\\end{cases}\\]\n\\[\\implies\\]\n\\[\\begin{cases}\nn_s=1-\\frac{n_s\\cdot P_r}{P_p}-\\frac{n_s\\cdot P_s}{P_p}\\implies n_s=\\frac{P_p}{P_p+P_r+P_s}&\\text{(6), substituting (4) into (5)}\\\\\nn_p=\\frac{n_s\\cdot P_r}{P_p}=\\frac{\\cancel{P_p}\\cdot P_r}{\\cancel{P_p}\\cdot (P_p+P_r+P_s)}=\\frac{P_r}{P_p+P_r+P_s}&\\text{(7), substituting (6) into (1)}\\\\\nn_r=\\frac{n_p\\cdot P_s}{P_r}=\\frac{\\cancel{P_r}\\cdot P_s}{\\cancel{P_r}\\cdot (P_p+P_r+P_s)}=\\frac{P_s}{P_p+P_r+P_s}&\\text{(8), substituting (7) into (2)}\\\\\n\\end{cases}\\]\nIn the following, we will refer to the population density at the fixed point as \\(R\\), \\(S\\) and \\(P\\) for species \\(r\\), \\(s\\) and \\(p\\) respectively.\nThe population densities at the fixed point are controlled by the invasion rate of the species they invade (the fixed point population of species \\(r\\) depends on the invasion rate of species \\(s\\), the fixed point population of species \\(s\\) depends on the invasion rate of species \\(p\\) and the fixed point population of species \\(p\\) depends on the invasion rate of species \\(r\\)). As a consequence, the most aggressive species never has the highest fixed-point population. Moreover, if the invasion probabilities of two species are held steady, then a decrease in the competitive ability of the third leads to an increase in its fixed-point population. For example, if the invasion rate of species \\(p\\) decreases, then the population at the fixed point of species \\(s\\) decreases and since there are less \\(s\\) individuals invading species \\(p\\), the population of \\(p\\) increases."
  },
  {
    "objectID": "notebooks/long_range_simulations.html#experiments",
    "href": "notebooks/long_range_simulations.html#experiments",
    "title": "Long range dispersal model",
    "section": "Experiments",
    "text": "Experiments\nImporting the necessary libraries:\n\n\nCode\nimport numpy\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport plotly.express as px\nimport plotly.graph_objects as go\nfrom matplotlib import colormaps\nfrom scipy.integrate import odeint\nfrom graphviz import Source\nfrom sympy import symbols, Matrix, Eq, solve\nnp.random.seed(0)\n\n\n\n1. Discrete-time model\n\n1.1. Finite population size\nDefining a function to simulate the evolution of the system for a world with \\(N\\) sites:\n\n\nCode\ndef simulate_finite_N(Pr, Ps, Pp, nr_init, ns_init, N=1000, epochs=100):\n    '''\n    Simulate the evolution of a population of three species over time\n    on a model world that has N available sites.\n\n    Parameters\n    ----------\n    Pr : float\n        The probability that a species of type r invades a species of type s.\n    Ps : float\n        The probability that a species of type s invades a species of type p.\n    Pp : float\n        The probability that a species of type p invades a species of type r.\n    nr_init : float\n        The initial proportion of species r in the population.\n    ns_init : float\n        The initial proportion of species s in the population.\n    N : int\n        The number of sites.\n    epochs : int\n        The number of time units to simulate.\n    '''\n\n    def check_P(P):\n        if P &lt; 0 or P &gt; 1:\n            raise ValueError('Pr, Ps and Pp must be between 0 and 1')\n        \n    check_P(Pr)\n    check_P(Ps)\n    check_P(Pp)\n    \n    if nr_init + ns_init &gt; 1:\n        raise ValueError('Initial species proportions must be less than 1')\n    \n    if N &lt; 1:\n        raise ValueError('Number of sites must be at least 1')\n    \n    if epochs &lt; 1:\n        raise ValueError('Number of steps must be at least 1')\n    \n    sites = numpy.zeros(N)\n\n    nr = []\n    ns = []\n    np = []\n\n    r_id = 1\n    s_id = 2\n    p_id = 3\n\n    # Initialize the sites\n    for i in range(N):\n        sites[i] = numpy.random.choice([r_id, s_id, p_id], p=[nr_init, ns_init, 1-nr_init-ns_init])\n\n    nr.append(numpy.sum(sites == r_id) / N)\n    ns.append(numpy.sum(sites == s_id) / N)\n    np.append(numpy.sum(sites == p_id) / N)\n\n    for t in range(1, epochs):\n        for step in range(N):\n            # choose two random sites\n            i = numpy.random.randint(0, N)\n            j = numpy.random.randint(0, N)\n            \n            if sites[i] == r_id and sites[j] == s_id: # rock beats scissors\n                if numpy.random.rand() &lt; Pr:\n                    sites[j] = r_id\n            elif sites[i] == s_id and sites[j] == p_id: # scissors beats paper\n                if numpy.random.rand() &lt; Ps:\n                    sites[j] = s_id\n            elif sites[i] == p_id and sites[j] == r_id: # paper beats rock\n                if numpy.random.rand() &lt; Pp:\n                    sites[j] = p_id\n        \n        nr.append(numpy.sum(sites == r_id) / N)\n        ns.append(numpy.sum(sites == s_id) / N)\n        np.append(numpy.sum(sites == p_id) / N)\n\n        # if two species go extinct, stop the simulation\n        if sum([numpy.isclose(nr[-1], 0, 1e-4),\n                numpy.isclose(ns[-1], 0, 1e-4),\n                numpy.isclose(np[-1], 0, 1e-4)\n            ]) &gt;= 2:\n            break\n    \n    return pd.DataFrame({'$n_r$': nr, '$n_s$': ns, '$n_p$': np})\n\n\nDefining functions to plot the evolution of the system:\n\n\nCode\ndef line_plot_species_evolution(df, title=None, show_markers=True):\n    '''\n    Plot the evolution of species proportions over time in a line plot.\n\n    Parameters\n    ----------\n    df : pd.DataFrame\n        A DataFrame containing the species proportions over time.\n    title : str\n        The title of the plot.\n    show_markers : bool\n        Whether to show markers on the plot.\n    '''\n    ax = df.plot(\n        figsize=(12, 4),\n        style='o-' if show_markers else '-', color=['tab:red', 'purple', 'gold'],\n        title=title,\n        xlabel='Time'\n    );\n    if show_markers:\n        for line in ax.get_lines():\n            line.set_markeredgecolor('black')\n\ndef phase_plot_species_evolution(df, title=None):\n    '''\n    Plot the evolution of species proportions over time in a phase plot.\n\n    Parameters\n    ----------\n    df : pd.DataFrame\n        A DataFrame containing the species proportions over time.\n    title : str\n        The title of the plot.\n    '''\n    fig, axs = plt.subplots(1, 3, figsize=(15, 5), sharey=True, sharex=True)\n    cmap = colormaps['Blues']\n    colors = cmap(np.linspace(0, 1, (df[df.columns[0]].shape[0]-1))) \n    for i in range(3):\n        axs[i].plot(df[df.columns[i]][0:-1], df[df.columns[i]][1:], '-', color='k', zorder=1)\n        axs[i].scatter(df[df.columns[i]][0:-1], df[df.columns[i]][1:], c=colors, s=50, zorder=2, edgecolor='black')\n        axs[i].set_title(df.columns[i])\n    fig.suptitle(title);\n    fig.tight_layout()\n\ndef ternary_plot_species_evolution(df, title=None, show_markers=True):\n    '''\n    Plot the evolution of species proportions over time in a ternary plot.\n    \n    Parameters\n    ----------\n    df : pd.DataFrame\n        A DataFrame containing the species proportions over time.\n    title : str\n        The title of the plot.\n    show_markers : bool\n        Whether to show markers on the plot.\n    '''\n    fig = px.scatter_ternary(\n        df,\n        a=df.columns[2],\n        b=df.columns[0],\n        c=df.columns[1],\n        color=df.index,\n        color_continuous_scale='blues',\n        size_max=10,\n        title=title\n    )\n    if show_markers:\n        fig.update_traces(mode='lines+markers', line=dict(color='black', width=1),\n            marker=dict(symbol='circle', line=dict(width=1, color='black')))\n    else:\n        fig.update_traces(mode='lines', line=dict(color='black', width=1))\n    fig.update_layout(coloraxis_colorbar=dict(title='Time'))\n    fig.show('png')\n\n\nSimulating the evolution of the system with \\(P_r = 0.2\\), \\(P_s = 0.5\\), \\(P_p = 0.3\\), \\(N = 1000\\), initialized with population densities closed to the fixed point (\\(n_r=0.5\\), \\(n_s=0.3\\), \\(n_p=0.2\\)):\n\n\nCode\nfinite_N_df = simulate_finite_N(Pr=0.2, Ps=0.5, Pp=0.3, nr_init=0.5, ns_init=0.3, N=1000, epochs=1000)\n\n\nPlotting the evolution of the system:\n\n\nCode\nline_plot_species_evolution(\n    finite_N_df,\n    title='N=1000, $P_r=0.2$, $P_s=0.5$, $P_p=0.3$, $n_r^0$=0.5, $n_s^0$=0.3, $n_p^0$=0.2'\n)\n\n\n\n\n\n\n\nCode\nphase_plot_species_evolution(\n    finite_N_df,\n    title='Phase portait\\nN=1000, $P_r=0.2$, $P_s=0.5$, $P_p=0.3$, $n_r^0$=0.5, $n_s^0$=0.3, $n_p^0$=0.2'\n)\n\n\n\n\n\nReplicating Figure 1b from [1]:\n\n\nCode\nternary_plot_species_evolution(\n    finite_N_df,\n    title=r\"$N=1000, P_r=0.2, P_s=0.5, P_p=0.3, n_r^0=0.5, n_s^0=0.3, n_p^0=0.2$\"\n)\n\n\n\n\n\nIn a finite world, the populations oscillate with increasing amplitude, with two species (scissors and paper) eventually becoming extinct. The species that survives (rock) is the one that has the lowest invasion rate.\nPerforming simulations for a range of invasion probabilities chosen to sum to unity, initializing the population densities close to the fixed point and recording the surviving species (replicating Figure 1c from [1]):\n\n\nCode\n# defining a grid of points for invasion probabilities\nR, S = np.mgrid[0:1:20j, 0:1:20j]\nR, S = R.ravel(), S.ravel()\nP = 1 - R - S\nI = np.array([R, S, P]).T\n# keeping only invasion probabilities greater than 0.01\nI = I[np.all(I &gt; 0.01, axis=1)]\nR = I[:, 0]\nS = I[:, 1]\nP = I[:, 2]\n# total number of simulations to run\nnum_sim = len(I)\n# number of sites \nN = 1000\n# maximum number of iterations\nEPOCHS = 2000\n# list to store the winner of each simulation\nwinners = []\n\n# iterating over the invasion probabilities\nfor i, (Pr, Ps, Pp) in enumerate(I):\n    print(f\"[{i+1}/{num_sim}] Running simulation for invasion probabilities: Pr={Pr:.2f}, Ps={Ps:.2f}, Pp={Pp:.2f}\")\n    # simulating with the current invasion probabilities\n    results_df = simulate_finite_N(\n        Pr=Pr, Ps=Ps, Pp=Pp,\n        nr_init=Ps, ns_init=Pp,\n        N=N, epochs=EPOCHS\n    )\n    # storing the winner\n    if results_df.index.stop==EPOCHS: # no winner\n        winners.append('None')\n    elif np.isclose(results_df.iloc[-1]['$n_r$'], 1, 1e-4): # rock wins\n            winners.append('Rock')\n    elif np.isclose(results_df.iloc[-1]['$n_s$'], 1, 1e-4): # scissors wins\n        winners.append('Scissors')\n    else: # paper wins\n        winners.append('Paper')\n\n\n[1/153] Running simulation for invasion probabilities: Pr=0.05, Ps=0.05, Pp=0.89\n[2/153] Running simulation for invasion probabilities: Pr=0.05, Ps=0.11, Pp=0.84\n[3/153] Running simulation for invasion probabilities: Pr=0.05, Ps=0.16, Pp=0.79\n[4/153] Running simulation for invasion probabilities: Pr=0.05, Ps=0.21, Pp=0.74\n[5/153] Running simulation for invasion probabilities: Pr=0.05, Ps=0.26, Pp=0.68\n[6/153] Running simulation for invasion probabilities: Pr=0.05, Ps=0.32, Pp=0.63\n[7/153] Running simulation for invasion probabilities: Pr=0.05, Ps=0.37, Pp=0.58\n[8/153] Running simulation for invasion probabilities: Pr=0.05, Ps=0.42, Pp=0.53\n[9/153] Running simulation for invasion probabilities: Pr=0.05, Ps=0.47, Pp=0.47\n[10/153] Running simulation for invasion probabilities: Pr=0.05, Ps=0.53, Pp=0.42\n[11/153] Running simulation for invasion probabilities: Pr=0.05, Ps=0.58, Pp=0.37\n[12/153] Running simulation for invasion probabilities: Pr=0.05, Ps=0.63, Pp=0.32\n[13/153] Running simulation for invasion probabilities: Pr=0.05, Ps=0.68, Pp=0.26\n[14/153] Running simulation for invasion probabilities: Pr=0.05, Ps=0.74, Pp=0.21\n[15/153] Running simulation for invasion probabilities: Pr=0.05, Ps=0.79, Pp=0.16\n[16/153] Running simulation for invasion probabilities: Pr=0.05, Ps=0.84, Pp=0.11\n[17/153] Running simulation for invasion probabilities: Pr=0.05, Ps=0.89, Pp=0.05\n[18/153] Running simulation for invasion probabilities: Pr=0.11, Ps=0.05, Pp=0.84\n[19/153] Running simulation for invasion probabilities: Pr=0.11, Ps=0.11, Pp=0.79\n[20/153] Running simulation for invasion probabilities: Pr=0.11, Ps=0.16, Pp=0.74\n[21/153] Running simulation for invasion probabilities: Pr=0.11, Ps=0.21, Pp=0.68\n[22/153] Running simulation for invasion probabilities: Pr=0.11, Ps=0.26, Pp=0.63\n[23/153] Running simulation for invasion probabilities: Pr=0.11, Ps=0.32, Pp=0.58\n[24/153] Running simulation for invasion probabilities: Pr=0.11, Ps=0.37, Pp=0.53\n[25/153] Running simulation for invasion probabilities: Pr=0.11, Ps=0.42, Pp=0.47\n[26/153] Running simulation for invasion probabilities: Pr=0.11, Ps=0.47, Pp=0.42\n[27/153] Running simulation for invasion probabilities: Pr=0.11, Ps=0.53, Pp=0.37\n[28/153] Running simulation for invasion probabilities: Pr=0.11, Ps=0.58, Pp=0.32\n[29/153] Running simulation for invasion probabilities: Pr=0.11, Ps=0.63, Pp=0.26\n[30/153] Running simulation for invasion probabilities: Pr=0.11, Ps=0.68, Pp=0.21\n[31/153] Running simulation for invasion probabilities: Pr=0.11, Ps=0.74, Pp=0.16\n[32/153] Running simulation for invasion probabilities: Pr=0.11, Ps=0.79, Pp=0.11\n[33/153] Running simulation for invasion probabilities: Pr=0.11, Ps=0.84, Pp=0.05\n[34/153] Running simulation for invasion probabilities: Pr=0.16, Ps=0.05, Pp=0.79\n[35/153] Running simulation for invasion probabilities: Pr=0.16, Ps=0.11, Pp=0.74\n[36/153] Running simulation for invasion probabilities: Pr=0.16, Ps=0.16, Pp=0.68\n[37/153] Running simulation for invasion probabilities: Pr=0.16, Ps=0.21, Pp=0.63\n[38/153] Running simulation for invasion probabilities: Pr=0.16, Ps=0.26, Pp=0.58\n[39/153] Running simulation for invasion probabilities: Pr=0.16, Ps=0.32, Pp=0.53\n[40/153] Running simulation for invasion probabilities: Pr=0.16, Ps=0.37, Pp=0.47\n[41/153] Running simulation for invasion probabilities: Pr=0.16, Ps=0.42, Pp=0.42\n[42/153] Running simulation for invasion probabilities: Pr=0.16, Ps=0.47, Pp=0.37\n[43/153] Running simulation for invasion probabilities: Pr=0.16, Ps=0.53, Pp=0.32\n[44/153] Running simulation for invasion probabilities: Pr=0.16, Ps=0.58, Pp=0.26\n[45/153] Running simulation for invasion probabilities: Pr=0.16, Ps=0.63, Pp=0.21\n[46/153] Running simulation for invasion probabilities: Pr=0.16, Ps=0.68, Pp=0.16\n[47/153] Running simulation for invasion probabilities: Pr=0.16, Ps=0.74, Pp=0.11\n[48/153] Running simulation for invasion probabilities: Pr=0.16, Ps=0.79, Pp=0.05\n[49/153] Running simulation for invasion probabilities: Pr=0.21, Ps=0.05, Pp=0.74\n[50/153] Running simulation for invasion probabilities: Pr=0.21, Ps=0.11, Pp=0.68\n[51/153] Running simulation for invasion probabilities: Pr=0.21, Ps=0.16, Pp=0.63\n[52/153] Running simulation for invasion probabilities: Pr=0.21, Ps=0.21, Pp=0.58\n[53/153] Running simulation for invasion probabilities: Pr=0.21, Ps=0.26, Pp=0.53\n[54/153] Running simulation for invasion probabilities: Pr=0.21, Ps=0.32, Pp=0.47\n[55/153] Running simulation for invasion probabilities: Pr=0.21, Ps=0.37, Pp=0.42\n[56/153] Running simulation for invasion probabilities: Pr=0.21, Ps=0.42, Pp=0.37\n[57/153] Running simulation for invasion probabilities: Pr=0.21, Ps=0.47, Pp=0.32\n[58/153] Running simulation for invasion probabilities: Pr=0.21, Ps=0.53, Pp=0.26\n[59/153] Running simulation for invasion probabilities: Pr=0.21, Ps=0.58, Pp=0.21\n[60/153] Running simulation for invasion probabilities: Pr=0.21, Ps=0.63, Pp=0.16\n[61/153] Running simulation for invasion probabilities: Pr=0.21, Ps=0.68, Pp=0.11\n[62/153] Running simulation for invasion probabilities: Pr=0.21, Ps=0.74, Pp=0.05\n[63/153] Running simulation for invasion probabilities: Pr=0.26, Ps=0.05, Pp=0.68\n[64/153] Running simulation for invasion probabilities: Pr=0.26, Ps=0.11, Pp=0.63\n[65/153] Running simulation for invasion probabilities: Pr=0.26, Ps=0.16, Pp=0.58\n[66/153] Running simulation for invasion probabilities: Pr=0.26, Ps=0.21, Pp=0.53\n[67/153] Running simulation for invasion probabilities: Pr=0.26, Ps=0.26, Pp=0.47\n[68/153] Running simulation for invasion probabilities: Pr=0.26, Ps=0.32, Pp=0.42\n[69/153] Running simulation for invasion probabilities: Pr=0.26, Ps=0.37, Pp=0.37\n[70/153] Running simulation for invasion probabilities: Pr=0.26, Ps=0.42, Pp=0.32\n[71/153] Running simulation for invasion probabilities: Pr=0.26, Ps=0.47, Pp=0.26\n[72/153] Running simulation for invasion probabilities: Pr=0.26, Ps=0.53, Pp=0.21\n[73/153] Running simulation for invasion probabilities: Pr=0.26, Ps=0.58, Pp=0.16\n[74/153] Running simulation for invasion probabilities: Pr=0.26, Ps=0.63, Pp=0.11\n[75/153] Running simulation for invasion probabilities: Pr=0.26, Ps=0.68, Pp=0.05\n[76/153] Running simulation for invasion probabilities: Pr=0.32, Ps=0.05, Pp=0.63\n[77/153] Running simulation for invasion probabilities: Pr=0.32, Ps=0.11, Pp=0.58\n[78/153] Running simulation for invasion probabilities: Pr=0.32, Ps=0.16, Pp=0.53\n[79/153] Running simulation for invasion probabilities: Pr=0.32, Ps=0.21, Pp=0.47\n[80/153] Running simulation for invasion probabilities: Pr=0.32, Ps=0.26, Pp=0.42\n[81/153] Running simulation for invasion probabilities: Pr=0.32, Ps=0.32, Pp=0.37\n[82/153] Running simulation for invasion probabilities: Pr=0.32, Ps=0.37, Pp=0.32\n[83/153] Running simulation for invasion probabilities: Pr=0.32, Ps=0.42, Pp=0.26\n[84/153] Running simulation for invasion probabilities: Pr=0.32, Ps=0.47, Pp=0.21\n[85/153] Running simulation for invasion probabilities: Pr=0.32, Ps=0.53, Pp=0.16\n[86/153] Running simulation for invasion probabilities: Pr=0.32, Ps=0.58, Pp=0.11\n[87/153] Running simulation for invasion probabilities: Pr=0.32, Ps=0.63, Pp=0.05\n[88/153] Running simulation for invasion probabilities: Pr=0.37, Ps=0.05, Pp=0.58\n[89/153] Running simulation for invasion probabilities: Pr=0.37, Ps=0.11, Pp=0.53\n[90/153] Running simulation for invasion probabilities: Pr=0.37, Ps=0.16, Pp=0.47\n[91/153] Running simulation for invasion probabilities: Pr=0.37, Ps=0.21, Pp=0.42\n[92/153] Running simulation for invasion probabilities: Pr=0.37, Ps=0.26, Pp=0.37\n[93/153] Running simulation for invasion probabilities: Pr=0.37, Ps=0.32, Pp=0.32\n[94/153] Running simulation for invasion probabilities: Pr=0.37, Ps=0.37, Pp=0.26\n[95/153] Running simulation for invasion probabilities: Pr=0.37, Ps=0.42, Pp=0.21\n[96/153] Running simulation for invasion probabilities: Pr=0.37, Ps=0.47, Pp=0.16\n[97/153] Running simulation for invasion probabilities: Pr=0.37, Ps=0.53, Pp=0.11\n[98/153] Running simulation for invasion probabilities: Pr=0.37, Ps=0.58, Pp=0.05\n[99/153] Running simulation for invasion probabilities: Pr=0.42, Ps=0.05, Pp=0.53\n[100/153] Running simulation for invasion probabilities: Pr=0.42, Ps=0.11, Pp=0.47\n[101/153] Running simulation for invasion probabilities: Pr=0.42, Ps=0.16, Pp=0.42\n[102/153] Running simulation for invasion probabilities: Pr=0.42, Ps=0.21, Pp=0.37\n[103/153] Running simulation for invasion probabilities: Pr=0.42, Ps=0.26, Pp=0.32\n[104/153] Running simulation for invasion probabilities: Pr=0.42, Ps=0.32, Pp=0.26\n[105/153] Running simulation for invasion probabilities: Pr=0.42, Ps=0.37, Pp=0.21\n[106/153] Running simulation for invasion probabilities: Pr=0.42, Ps=0.42, Pp=0.16\n[107/153] Running simulation for invasion probabilities: Pr=0.42, Ps=0.47, Pp=0.11\n[108/153] Running simulation for invasion probabilities: Pr=0.42, Ps=0.53, Pp=0.05\n[109/153] Running simulation for invasion probabilities: Pr=0.47, Ps=0.05, Pp=0.47\n[110/153] Running simulation for invasion probabilities: Pr=0.47, Ps=0.11, Pp=0.42\n[111/153] Running simulation for invasion probabilities: Pr=0.47, Ps=0.16, Pp=0.37\n[112/153] Running simulation for invasion probabilities: Pr=0.47, Ps=0.21, Pp=0.32\n[113/153] Running simulation for invasion probabilities: Pr=0.47, Ps=0.26, Pp=0.26\n[114/153] Running simulation for invasion probabilities: Pr=0.47, Ps=0.32, Pp=0.21\n[115/153] Running simulation for invasion probabilities: Pr=0.47, Ps=0.37, Pp=0.16\n[116/153] Running simulation for invasion probabilities: Pr=0.47, Ps=0.42, Pp=0.11\n[117/153] Running simulation for invasion probabilities: Pr=0.47, Ps=0.47, Pp=0.05\n[118/153] Running simulation for invasion probabilities: Pr=0.53, Ps=0.05, Pp=0.42\n[119/153] Running simulation for invasion probabilities: Pr=0.53, Ps=0.11, Pp=0.37\n[120/153] Running simulation for invasion probabilities: Pr=0.53, Ps=0.16, Pp=0.32\n[121/153] Running simulation for invasion probabilities: Pr=0.53, Ps=0.21, Pp=0.26\n[122/153] Running simulation for invasion probabilities: Pr=0.53, Ps=0.26, Pp=0.21\n[123/153] Running simulation for invasion probabilities: Pr=0.53, Ps=0.32, Pp=0.16\n[124/153] Running simulation for invasion probabilities: Pr=0.53, Ps=0.37, Pp=0.11\n[125/153] Running simulation for invasion probabilities: Pr=0.53, Ps=0.42, Pp=0.05\n[126/153] Running simulation for invasion probabilities: Pr=0.58, Ps=0.05, Pp=0.37\n[127/153] Running simulation for invasion probabilities: Pr=0.58, Ps=0.11, Pp=0.32\n[128/153] Running simulation for invasion probabilities: Pr=0.58, Ps=0.16, Pp=0.26\n[129/153] Running simulation for invasion probabilities: Pr=0.58, Ps=0.21, Pp=0.21\n[130/153] Running simulation for invasion probabilities: Pr=0.58, Ps=0.26, Pp=0.16\n[131/153] Running simulation for invasion probabilities: Pr=0.58, Ps=0.32, Pp=0.11\n[132/153] Running simulation for invasion probabilities: Pr=0.58, Ps=0.37, Pp=0.05\n[133/153] Running simulation for invasion probabilities: Pr=0.63, Ps=0.05, Pp=0.32\n[134/153] Running simulation for invasion probabilities: Pr=0.63, Ps=0.11, Pp=0.26\n[135/153] Running simulation for invasion probabilities: Pr=0.63, Ps=0.16, Pp=0.21\n[136/153] Running simulation for invasion probabilities: Pr=0.63, Ps=0.21, Pp=0.16\n[137/153] Running simulation for invasion probabilities: Pr=0.63, Ps=0.26, Pp=0.11\n[138/153] Running simulation for invasion probabilities: Pr=0.63, Ps=0.32, Pp=0.05\n[139/153] Running simulation for invasion probabilities: Pr=0.68, Ps=0.05, Pp=0.26\n[140/153] Running simulation for invasion probabilities: Pr=0.68, Ps=0.11, Pp=0.21\n[141/153] Running simulation for invasion probabilities: Pr=0.68, Ps=0.16, Pp=0.16\n[142/153] Running simulation for invasion probabilities: Pr=0.68, Ps=0.21, Pp=0.11\n[143/153] Running simulation for invasion probabilities: Pr=0.68, Ps=0.26, Pp=0.05\n[144/153] Running simulation for invasion probabilities: Pr=0.74, Ps=0.05, Pp=0.21\n[145/153] Running simulation for invasion probabilities: Pr=0.74, Ps=0.11, Pp=0.16\n[146/153] Running simulation for invasion probabilities: Pr=0.74, Ps=0.16, Pp=0.11\n[147/153] Running simulation for invasion probabilities: Pr=0.74, Ps=0.21, Pp=0.05\n[148/153] Running simulation for invasion probabilities: Pr=0.79, Ps=0.05, Pp=0.16\n[149/153] Running simulation for invasion probabilities: Pr=0.79, Ps=0.11, Pp=0.11\n[150/153] Running simulation for invasion probabilities: Pr=0.79, Ps=0.16, Pp=0.05\n[151/153] Running simulation for invasion probabilities: Pr=0.84, Ps=0.05, Pp=0.11\n[152/153] Running simulation for invasion probabilities: Pr=0.84, Ps=0.11, Pp=0.05\n[153/153] Running simulation for invasion probabilities: Pr=0.89, Ps=0.05, Pp=0.05\n\n\nPlotting the surviving species on a ternary plot:\n\n\nCode\nfig = px.scatter_ternary(\n    pd.DataFrame(I, columns=['$P_r$', '$P_s$', '$P_p$']),\n    a=\"$P_p$\",\n    b=\"$P_r$\",\n    c=\"$P_s$\",\n    size_max=10,\n    title=f\"Surviving species after {EPOCHS} epochs&lt;br&gt;N={N}, population densities initialized with their value at the fixed point\",\n    color = winners,\n    color_discrete_map={'None': 'black', 'Rock': 'red', 'Scissors': 'purple', 'Paper': 'gold'}\n    )\nfig.update_layout(legend_title_text='Winner')\nfig.show('png')\n\n\n\n\n\nThe weakest competitor is most likely to survive.\n\n\n1.2. Large population size\nTo transform the differential equations describing the system under the large \\(N\\) assumption into discrete-time recurrence relations, we approximate the derivative \\(\\frac{\\partial n_r}{\\partial t}\\) by the difference between the population densities at consecutive time steps\n\\[\\frac{\\partial n_r}{\\partial t}=\\frac{n_r[t+1]-n_r[t]}{\\Delta_t}\\]\nand we solve for \\(n_r[t+1]\\), obtaining\n\\[n_r[t+\\Delta_t]=n_r[t] + \\Delta_t \\cdot n_r[t](n_s[t]P_r - n_p[t] P_p)\\]\nApplying the same reasoning to the other equations, we obtain the following system of recurrence equations:\n\\[\\begin{cases}\nn_r[t+\\Delta_t]=n_r[t] + \\Delta_t \\cdot n_r[t](n_s[t]P_r - n_p[t] P_p)\\\\\nn_s[t+\\Delta_t]=n_s[t] + \\Delta_t \\cdot n_s[t](n_p[t]P_s - n_r[t] P_r)\\\\\nn_p[t+\\Delta_t]=n_p[t] + \\Delta_t \\cdot n_p[t](n_r[t]P_p - n_s[t] P_s)\\\\\n\\end{cases}\\]\nDefining a function to simulate the evolution of the system of recurrent equations under the large \\(N\\) assumption:\n\n\nCode\ndef simulate_large_N(Pr, Ps, Pp, nr_init, ns_init, delta_t=0.001, epochs=1000):\n    '''\n    Simulate the evolution of a population of three species over time using \n    the recurrence relations under the large N assumption.\n\n    Parameters\n    ----------\n    Pr : float\n        The probability that a species of type r invades a species of type s.\n    Ps : float\n        The probability that a species of type s invades a species of type p.\n    Pp : float\n        The probability that a species of type p invades a species of type r.\n    nr_init : float\n        The initial proportion of species r in the population.\n    ns_init : float\n        The initial proportion of species s in the population.\n    delta_t : float\n        The time step size.\n    epochs : int\n        The number of time units to simulate.\n    '''\n\n    def check_P(P):\n        if P &lt; 0 or P &gt; 1:\n            raise ValueError('Pr, Ps and Pp must be between 0 and 1')\n        \n    check_P(Pr)\n    check_P(Ps)\n    check_P(Pp)\n    \n    if nr_init + ns_init &gt; 1:\n        raise ValueError('Initial species proportions must be less than 1')\n    \n    if epochs &lt; 1:\n        raise ValueError('Number of steps must be at least 1')\n    \n    nr = []\n    ns = []\n    np = []\n\n    nr.append(nr_init)\n    ns.append(ns_init)\n    np.append(1 - nr_init - ns_init)\n\n    for _ in range(0, epochs-1):\n        nr.append(nr[-1] + nr[-1]*delta_t*(ns[-1]*Pr - np[-1]*Pp))\n        ns.append(ns[-1] + ns[-1]*delta_t*(np[-1]*Ps - nr[-2]*Pr)) # use nr from the previous time step\n        np.append(1 - nr[-1] - ns[-1])\n\n        # if two species go extinct, stop the simulation\n        if sum([numpy.isclose(nr[-1], 0, 1e-4),\n                numpy.isclose(ns[-1], 0, 1e-4),\n                numpy.isclose(np[-1], 0, 1e-4)]) &gt;= 2:\n            break\n    \n    return pd.DataFrame({'$n_r$': nr, '$n_s$': ns, '$n_p$': np})\n\n\nSimulating the evolution of the system of recurrent equations under the large \\(N\\) assumption with \\(P_r = 0.2\\), \\(P_s = 0.5\\), \\(P_p = 0.3\\), initialized with population densities close to the fixed point (\\(n_r=0.5\\), \\(n_s=0.3\\), \\(n_p=0.2\\)):\n\n\nCode\nfp_large_N_df = simulate_large_N(Pr=0.2, Ps=0.5, Pp=0.3, nr_init=0.5, ns_init=0.3, epochs=100)\n\n\nPlotting the evolution of the system:\n\n\nCode\nline_plot_species_evolution(\n    fp_large_N_df,\n    title='Large N assumption, $P_r=0.2$, $P_s=0.5$, $P_p=0.3$, $n_r^0$=0.5, $n_s^0$=0.3, $n_p^0=0.2$'\n)\n\n\n\n\n\nBy initializing the population densities equal to the fixed point, the system remains at the fixed point.\nSimulating the evolution of the system under the large \\(N\\) assumption with \\(P_r = 0.2\\), \\(P_s = 0.5\\), \\(P_p = 0.3\\), initialized with equal population densities (\\(n_r=1/3\\), \\(n_s=1/3\\), \\(n_p=1/3\\)) and using \\(\\Delta_t=1\\):\n\n\nCode\neq_large_N_df = simulate_large_N(Pr=0.2, Ps=0.5, Pp=0.3, nr_init=1/3, ns_init=1/3, delta_t=1, epochs=1000)\n\n\nPlotting the evolution of the system:\n\n\nCode\nline_plot_species_evolution(\n    eq_large_N_df,\n    title='Large N assumption, $P_r=0.2$, $P_s=0.5$, $P_p=0.3$, $n_r^0$=1/3, $n_s^0$=1/3, $n_p^0$=1/3'\n)\n\n\n\n\n\n\n\nCode\nternary_plot_species_evolution(\n    eq_large_N_df,\n    title=r\"$\\text{Large N assumption, }P_r=0.2, P_s=0.5, P_p=0.3, n_r^0=1/3, n_s^0=1/3, n_p^0=1/3$\"\n)\n\n\n\n\n\nSimulating the evolution of the system with \\(\\Delta_t=0.01\\) to increase accuracy:\n\n\nCode\neq_large_N_df = simulate_large_N(Pr=0.2, Ps=0.5, Pp=0.3, nr_init=1/3, ns_init=1/3, delta_t=0.01, epochs=100000)\n\n\nPlotting the evolution of the system:\n\n\nCode\nline_plot_species_evolution(\n    eq_large_N_df,\n    title='Large N assumption, $P_r=0.2$, $P_s=0.5$, $P_p=0.3$, $n_r^0$=1/3, $n_s^0$=1/3',\n    show_markers=False\n)\n\n\n\n\n\n\n\nCode\nternary_plot_species_evolution(\n    eq_large_N_df,\n    title=r\"$\\text{Large N assumption, }P_r=0.2, P_s=0.5, P_p=0.3, n_r^0=1/3, n_s^0=1/3$\",\n    show_markers=False\n)\n\n\n\n\n\nIn the limit that the total number of sites is large, the populations exhibit sustained oscillations, moving along a periodic orbit around the fixed point (\\(n_r=0.5, n_s=0.3, n_p=0.2\\)).\n\n\n\n2. Continuous-time model\nTo enhance accuracy, we simulate the system’s evolution by solving the differential equations that define it.\nThe odeint method from scipy.integrate solves a system of ordinary differential equations using lsoda from the FORTRAN library odepack. This library uses the Adams/BDF method with automatic stiffness detection.\n\n\nCode\ndef RSP_ODE_solver(t, P, x0):\n    '''\n    Solve the initial value problem for the RSP ODE system.\n    '''\n    def RSP(x, t, P):\n        nr = x[0]\n        Pr = P[0]\n        ns = x[1]\n        Ps = P[1]\n        np = 1 - nr - ns\n        Pp = P[2]\n\n        d_nr_dt = nr*(ns*Pr - np*Pp)\n        d_ns_dt = ns*(np*Ps - nr*Pr)\n        return [d_nr_dt, d_ns_dt]\n\n    y = odeint(RSP, x0, t, args=(P,))\n    results_df = pd.DataFrame(y, columns=['$n_r$', '$n_s$'])\n    results_df['$n_p$'] = 1 - results_df['$n_r$'] - results_df['$n_s$']\n    return results_df\n\ndef simulate_continuous(t, Pr, Ps, Pp, nr_init, ns_init):\n    '''\n    Simulate the evolution of a population of three species over time in the\n    continuous setting, solving the initial value problem for the ODE system.\n    '''\n    if nr_init + ns_init &gt; 1:\n        raise ValueError('Initial species proportions must be less than 1')\n    \n    def check_P(P):\n        if P &lt; 0 or P &gt; 1:\n            raise ValueError('P_r, P_s and P_p must be between 0 and 1')\n        \n    check_P(Pr)\n    check_P(Ps)\n    check_P(Pp)\n\n    P = [Pr, Ps, Pp]\n    x0 = [nr_init, ns_init]\n    s = RSP_ODE_solver(t, P, x0)\n    return s\n\n\nSimulating the evolution of the system in the continuous setting with \\(P_r = 0.2\\), \\(P_s = 0.5\\), \\(P_p = 0.3\\), initialized with population densities close to the fixed point (\\(n_r=0.5\\), \\(n_s=0.3\\), \\(n_p=0.2\\)):\n\n\nCode\nfp_continuous_df = simulate_continuous(t=np.linspace(0,100,101), Pr=0.2, Ps=0.5, Pp=0.3, nr_init=0.5, ns_init=0.3)\n\n\nPlotting the evolution of the system:\n\n\nCode\nline_plot_species_evolution(\n    fp_continuous_df,\n    title='$P_r=0.2$, $P_s=0.5$, $P_p=0.3$, $n_r^0$=0.5, $n_s^0$=0.3'\n)\n\n\n\n\n\nAs in the discrete time setting, by initializing the population densities equal to the fixed point, the system remains at the fixed point.\nSimulating the evolution of the system in the continuous setting with \\(P_r = 0.2\\), \\(P_s = 0.5\\), \\(P_p = 0.3\\), initialized with equal population densities (\\(n_r=1/3\\), \\(n_s=1/3\\), \\(n_p=1/3\\)):\n\n\nCode\neq_continuous_df = simulate_continuous(t=np.linspace(0,1000,1001), Pr=0.2, Ps=0.5, Pp=0.3, nr_init=1/3, ns_init=1/3)\n\n\nPlottting the evolution of the system:\n\n\nCode\nline_plot_species_evolution(\n    eq_continuous_df,\n    title='$P_r=0.2$, $P_s=0.5$, $P_p=0.3$, $n_r^0$=1/3, $n_s^0$=1/3'\n)\n\n\n\n\n\n\n\nCode\nternary_plot_species_evolution(\n    eq_continuous_df,\n    title=r\"$P_r=0.2, P_s=0.5, P_p=0.3, n_r^0=1/3, n_s^0=1/3$\"\n)\n\n\n\n\n\nAgain, the populations move along a periodic orbit around the fixed point.\nPerforming simulations for different initial population densities and plotting the orbits on a ternary plot (replicating Figure 1a from [1]):\n\n\nCode\nfig = go.Figure()\n# iterating over initial proportions\nfor i, init in enumerate([0.1, 0.2, 0.3, 0.4]):\n    # simulate the system\n    df = simulate_continuous(t=np.linspace(0,100,101), Pr=0.2, Ps=0.5, Pp=0.3, nr_init=init, ns_init=init)\n    # plot the trajectory\n    fig.add_trace(go.Scatterternary(\n        mode='lines',\n        a=df['$n_p$'],\n        b=df['$n_r$'],\n        c=df['$n_s$'],\n        name=f'$n_r^0={init}, n_s^0={init}$',\n        line=dict(color=px.colors.qualitative.Dark2[i], width=1)\n    ))\nfig.update_layout(\n    ternary=dict(\n        aaxis_title='$n_p$',\n        baxis_title='$n_r$',\n        caxis_title='$n_s$'\n    ),\n    title=r\"$\\text{Periodic orbits around the non-trivial fixed point}\\\\P_r=0.2, P_s=0.5, P_p=0.3$\",\n    legend=dict(\n        title='Initial conditions'\n    )\n)\nfig.show('png')\n\n\n\n\n\nThe quantity \\(\\lambda=(\\frac{n_r}{R})^R(\\frac{n_s}{S})^S(\\frac{n_p}{P})^P\\) is invariant along each orbit, with \\(\\lambda=1\\) when the populations are at the fixed point and \\(\\lambda=0\\) when one or more of the species become extinct [2].\nDefining a function to calculate the invariant:\n\n\nCode\ndef compute_lambda(df, Pr, Ps, Pp):\n    df['lambda'] = (df['$n_r$']/0.5)**Ps*(df['$n_s$']/Pp)**Pp*(df['$n_p$']/Pr)**Pr\n    return df\n\n\nComputing and plotting the orbit invariant:\n\n\nCode\neq_continuous_df = compute_lambda(eq_continuous_df, Pr=0.2, Ps=0.5, Pp=0.3)\neq_continuous_df['lambda'].apply(lambda x: round(x, 2)).plot(\n    figsize=(12,4),\n    y='lambda',\n    style='-', label='$\\lambda$',\n    title='Orbit invariant\\n$P_r=0.2$, $P_s=0.5$, $P_p=0.3$, $n_r^0=1/3$, $n_s^0=1/3$, $n_p^0=1/3$'\n)\nplt.legend()\n\n\n&lt;matplotlib.legend.Legend at 0x2a380ec10&gt;\n\n\n\n\n\n\n\n3. Stochastic simulation of chemical reactions\nWhile ODEs are deterministic and do not account for fluctuations in population densities, stochastic simulation methods offer greater accuracy, particularly when analyzing reaction systems with small quantities of molecules. Furthermore, unlike discrete time simulations, stochastic simulations use an exponential probability distribution to model the time between subsequent occurrences of an event.\nTo perform stochastic simulations, we need to translate the ODE system\n\\[\\begin{cases}\n\\frac{\\partial n_r}{\\partial t}=\\textcolor{violet}{n_r\\cdot n_s\\cdot P_r} - \\textcolor{gold}{n_r \\cdot n_p \\cdot P_p}\\\\\n\\frac{\\partial n_s}{\\partial t}=\\textcolor{cyan}{n_s\\cdot n_p\\cdot P_s} - \\textcolor{orange}{n_s\\cdot n_r \\cdot P_r}\\\\\n\\frac{\\partial n_p}{\\partial t}=\\textcolor{palegreen}{n_p\\cdot n_r\\cdot P_p} - \\textcolor{red}{n_p\\cdot n_s \\cdot P_s}\\\\\n\\end{cases}\\]\ninto a system of chemical reactions, by constructing one reaction for each term of the equations as follows\n\\[\\begin{cases}\n\\textcolor{violet}{R + S \\xrightarrow{P_r} S + 2R}\\\\\n\\textcolor{gold}{R + P \\xrightarrow{P_p} P}\\\\\n\\textcolor{cyan}{S + P \\xrightarrow{P_s} P + 2S}\\\\\n\\textcolor{orange}{S + R \\xrightarrow{P_r} R}\\\\\n\\textcolor{palegreen}{P + R \\xrightarrow{P_p} R + 2P}\\\\\n\\textcolor{red}{P + S \\xrightarrow{P_s} S}\\\\\n\\end{cases}\\]\nwhere we use the capital letters \\(R, S, P\\) to denote the species rock, scissors and paper respectively.\nWe can simplify the system by noting, for example, that the terms \\(\\textcolor{violet}{n_r\\cdot n_s\\cdot P_r}\\) and \\(\\textcolor{orange}{n_s\\cdot n_r \\cdot P_r}\\) can be represented by the same reaction (i.e., when an \\(R\\) individual wins, it reproduces while the losing \\(S\\) individual dies). Thus, we can combine these into a single reaction and apply the same process to similar terms, resulting in the following system:\n\\[\\begin{cases}\nR + S \\xrightarrow{P_r} 2R\\\\\nS + P \\xrightarrow{P_s} 2S\\\\\nP + R \\xrightarrow{P_p} 2P\\\\\n\\end{cases}\\]\nWe will use StochPy, a Python package for stochastic simulation of chemical reactions:\n\n\nCode\nimport stochpy\n\n\n\n#######################################################################\n#                                                                     #\n#            Welcome to the interactive StochPy environment           #\n#                                                                     #\n#######################################################################\n#  StochPy: Stochastic modeling in Python                             #\n#  http://stochpy.sourceforge.net                                     #\n#  Copyright(C) T.R Maarleveld, B.G. Olivier, F.J Bruggeman 2010-2015 #\n#  DOI: 10.1371/journal.pone.0079345                                  #\n#  Email: tmd200@users.sourceforge.net                                #\n#  VU University, Amsterdam, Netherlands                              #\n#  Centrum Wiskunde Informatica, Amsterdam, Netherlands               #\n#  StochPy is distributed under the BSD licence.                      #\n#######################################################################\n\nVersion 2.4.0\nOutput Directory: /Users/irenetesta/Stochpy\nModel Directory: /Users/irenetesta/Stochpy/pscmodels\n\n\nTo describe a system of chemical reaction, StochPy uses the PySCeS MDL, an ASCII text based input file. We defined the system using such format and saved it in the file ../long_range_models/RSP_model_reduced.psc:\n\n\nCode\n!cat ../long_range_models/RSP_model_reduced.psc\n\n\n# Rock Scissors Paper model\n\n# R + S  --&gt; 2R, Pr\n# P + R --&gt; 2P, Pp\n# S + P --&gt; 2S, Ps\n\nR1:\n    R + S &gt; R + R\n    R*S*Pr\n\nR2:\n    S + P &gt; S + S\n    S*P*Ps\n\nR3: \n    P + R &gt; P + P\n    P*R*Pp\n\n# Parameters\nPr = 0.2\nPs = 0.5\nPp = 0.3\n\n# Init Values\nR = 33\nS = 33\nP = 33\n\n\nLoading the model:\n\n\nCode\nsmod = stochpy.SSA(IsQuiet=False)\nsmod.Model(model_file=\"RSP_model_reduced.psc\",dir=\"../long_range_models/\")\nsmod.ShowSpecies()\n\n\nInfo: Direct method is selected to perform stochastic simulations.\nParsing file: /Users/irenetesta/Stochpy/pscmodels/ImmigrationDeath.psc\nInfo: No reagents have been fixed\nParsing file: ../long_range_models/RSP_model_reduced.psc\nInfo: No reagents have been fixed\n['R', 'S', 'P']\n\n\nSetting initial conditions (close to the fixed point) and parameters, using a high number of copies for each species to approximate the deterministic behavior of the system:\n\n\nCode\nsmod.ChangeParameter(\"Pr\", 0.2)\nsmod.ChangeParameter(\"Ps\", 0.5)\nsmod.ChangeParameter(\"Pp\", 0.3)\nsmod.ChangeInitialSpeciesCopyNumber(\"R\", 50000)\nsmod.ChangeInitialSpeciesCopyNumber(\"S\", 30000)\nsmod.ChangeInitialSpeciesCopyNumber(\"P\", 20000)\n\n\nThe method to perform a stochastic simulation is DoStochSim:\n\n\nCode\nhelp(smod.DoStochSim)\n\n\nHelp on method DoStochSim in module stochpy.modules.StochSim:\n\nDoStochSim(end=False, mode=False, method=False, trajectories=False, epsilon=0.03, IsTrackPropensities=False, rate_selection=None, species_selection=None, IsOnlyLastTimepoint=False, critical_reactions=[], reaction_orders=False, species_HORs=False, species_max_influence=False, quiet=False) method of stochpy.modules.StochSim.SSA instance\n    Run a stochastic simulation for until `end` is reached. This can be either time steps or end time (which could be a *HUGE* number of steps).\n    \n    Input:\n     - *end* [default=1000] (float) simulation end (steps or time)\n     - *mode* [default='steps'] (string) simulation mode, can be one of: ['steps','time']\n     - *method* [default='Direct'] (string) stochastic algorithm ['Direct', 'FRM', 'NRM', 'TauLeap']\n     - *trajectories* [default = 1] (integer)\n     - *epsilon* [default = 0.03] (float) parameter for the tau-leap method\n     - *IsTrackPropensities* [default = False]\n     - *rate_selection* [default = None] (list) of names of rates to store. This saves memory space and prevents Memory Errors when propensities propensities are tracked\n     - *species_selection* [default = None] (list) of names of species to store. This saves memory space and prevents Memory Errors (occurring at ~15 species).\n     - *IsOnlyLastTimepoint* [default = False] (boolean)\n     - *critical_reactions* [default = [] ] (list) ONLY for the tau-leaping method where the user can pre-define reactions that are \"critical\". Critical reactions can fire only once per time step.\n     - *reaction_orders* [default = [] (list) ONLY for the tau-leaping method \n     - *species_HORs* [default = []  (list) ONLY for the tau-leaping method \n     - *species_max_influence* [default = []]  (list) ONLY for the tau-leaping method \n     - *quiet* [default = False] suppress print statements\n\n\n\nIn the following, we will only use the Direct method as its variants are designed to reduce computational costs, which is not a concern for the simulations we will perform.\nPerforming a stochastic simulation using default parameters:\n\n\nCode\nsmod.DoStochSim()\nsmod.PlotSpeciesTimeSeries(colors=[\"tab:red\", \"purple\", \"gold\"], xlabel=\"Steps\")\nstochpy.plt.title(\"$P_r=0.2$, $P_s=0.5$, $P_p=0.3$, $R=50000$, $S=30000$, $P=20000$\");\n\n\nInfo: 1 trajectory is generated\nsimulation done!               \nInfo: Number of time steps 1000 End time 1.0951329075756742e-06\nInfo: Simulation time 0.00977\n\n\n\n\n\nAs in deterministic simulations, using a high number of molecules and initializing species copy number close to the fixed point, ensures that the system remains at the fixed point.\nPerforming a stochastic simulation with a lower number of molecules and tracking reaction propensities:\n\n\nCode\nsmod.ChangeInitialSpeciesCopyNumber(\"R\", 50)\nsmod.ChangeInitialSpeciesCopyNumber(\"S\", 30)\nsmod.ChangeInitialSpeciesCopyNumber(\"P\", 20)\nsmod.DoStochSim(end=10000, IsTrackPropensities=True)\nfp_stoch_df = pd.DataFrame(smod.data_stochsim.species, columns=['R', 'S', 'P'])\n\n\nInfo: 1 trajectory is generated\nsimulation done!               \nInfo: Number of time steps 1928 End time 2.519492477708811\nInfo: Simulation time 0.02972\n\n\nPlotting the evolution of the system:\n\n\nCode\nsmod.PlotSpeciesTimeSeries(colors=[\"tab:red\", \"purple\", \"gold\"], xlabel=\"Steps\")\nstochpy.plt.title(\"$P_r=0.2$, $P_s=0.5$, $P_p=0.3$, $R=50$, $S=30$, $P=20$\");\n\n\n\n\n\n\n\nCode\nternary_plot_species_evolution(\n    fp_stoch_df,\n    title=r\"$P_r=0.2, P_s=0.5, P_p=0.3, R=50, S=30, P=20$\",\n)\n\n\n\n\n\nWith fewer molecules, two species (scissors and paper) eventually become extinct, and the species that survives (rock) is the one that has the lowest invasion rate, similarly to the discrete-time model with a finite number of sites.\nVisualizing reaction propensities:\n\n\nCode\nsmod.PlotPropensitiesTimeSeries(title='Reaction Propensities, direct method\\n$P_r=0.2$, $P_s=0.5$, $P_p=0.3$, $R=50$, $S=30$, $P=20$')\n\n\n\n\n\nAt \\(t=0\\), \\(R1\\) propensity is \\(R\\cdot S\\cdot P_r=50\\cdot 30\\cdot 0.2=300\\), \\(R2\\) propensity is \\(S\\cdot P\\cdot P_s=30\\cdot 20\\cdot 0.5=300\\) and \\(R3\\) propensity is \\(P\\cdot R\\cdot P_p=20\\cdot 50\\cdot 0.3=300\\), where \\(R,S,P\\) denote the number of molecules of each species. The propensities of the reactions are equal, which is expected as the system is at the fixed point. However, due to the stochastic nature of the model, the system quickly deviates from this point.\nPlotting the time between two subsequent firings of a reaction:\n\n\nCode\nsmod.PlotWaitingtimesDistributions(title='Time between subsequent firings of reactions, direct method\\n$P_r=0.2$, $P_s=0.5$, $P_p=0.3$, $R=50$, $S=30$, $P=20$')\nsmod.PrintWaitingtimesMeans()\n\n\nReaction    Mean\nR1  0.004\nR2  0.004\nR3  0.004\n\n\n\n\n\nThe three reactions have the same average time between two subsequent firings. \\(R2\\) waiting times are longer than \\(R1\\) and \\(R3\\) because the number of molecules of species \\(S\\) and \\(P\\) is lower than the number of molecules of species \\(R\\).\nTo approximate the deterministic behavior we can either perform multiple stochastic simulations and average the species copy numbers at each time point:\n\n\nCode\nsmod.DoStochSim(end=100, trajectories=100)\nsmod.GetRegularGrid(n_samples=50)\nsmod.PlotAverageSpeciesTimeSeries(\n    colors=[\"tab:red\", \"purple\", \"gold\"],\n    title=\"Average species in 100 stochastic simulations, direct method\\n$P_r=0.2$, $P_s=0.5$, $P_p=0.3$, $R=50$, $S=30$, $P=20$\")\n\n\nInfo: 100 trajectories are generated\nInfo: Time simulation output of the trajectories is stored at RSP_model_reduced(trajectory).dat in directory: /Users/irenetesta/Stochpy/temp\nInfo: Simulation time: 0.15464997291564941                                                   \n\n\n\n\n\nTo get an accurate prediction of the species distribution StochPy provides the function DoCompleteStochSim() that continues the simulation until the first four moments converge within a user-specified error (default = 0.001):\n\n\nCode\nsmod.DoCompleteStochSim()\nsmod.PlotSpeciesDistributions(\n    colors=[\"tab:red\", \"purple\", \"gold\"],\n    title=\"Species distribution, direct method\\n$P_r=0.2$, $P_s=0.5$, $P_p=0.3$, $R=50$, $S=30$, $P=20$\")\n\n\nInfo: 100000 time steps simulated\nInfo: 200000 time steps simulated\nInfo: 300000 time steps simulated\nInfo: 400000 time steps simulated\nInfo: 500000 time steps simulated\nInfo: 600000 time steps simulated\nInfo: 700000 time steps simulated\nInfo: 800000 time steps simulated\nInfo: 900000 time steps simulated\nInfo: 1000000 time steps simulated\nInfo: 1100000 time steps simulated\nInfo: 1200000 time steps simulated\nInfo: 1300000 time steps simulated\nInfo: 1400000 time steps simulated\nInfo: 1500000 time steps simulated\nInfo: 1600000 time steps simulated\nInfo: 1700000 time steps simulated\nInfo: 1800000 time steps simulated\nInfo: 1900000 time steps simulated\nInfo: 2000000 time steps simulated\nInfo: 2100000 time steps simulated\nInfo: 2200000 time steps simulated\nInfo: 2300000 time steps simulated\nInfo: 2400000 time steps simulated\nInfo: 2500000 time steps simulated\nInfo: 2600000 time steps simulated\nInfo: 2700000 time steps simulated\nInfo: 2800000 time steps simulated\nInfo: 2900000 time steps simulated\nInfo: 3000000 time steps simulated\nInfo: 3100000 time steps simulated\nInfo: 3200000 time steps simulated\nInfo: 3300000 time steps simulated\nInfo: 3400000 time steps simulated\nInfo: 3500000 time steps simulated\nInfo: 3600000 time steps simulated\nInfo: 3700000 time steps simulated\nInfo: 3800000 time steps simulated\nInfo: 3900000 time steps simulated\nInfo: 4000000 time steps simulated\nInfo: 4100000 time steps simulated\nInfo: 4200000 time steps simulated\nInfo: 4300000 time steps simulated\nInfo: 4400000 time steps simulated\nInfo: 4500000 time steps simulated\nInfo: 4600000 time steps simulated\nInfo: 4700000 time steps simulated\nInfo: 4800000 time steps simulated\nInfo: 4900000 time steps simulated\nInfo: 5000000 time steps simulated\nInfo: 5100000 time steps simulated\nInfo: 5200000 time steps simulated\nInfo: 5300000 time steps simulated\nInfo: 5400000 time steps simulated\nInfo: 5500000 time steps simulated\nInfo: 5600000 time steps simulated\nInfo: 5700000 time steps simulated\nInfo: 5800000 time steps simulated\nInfo: 5900000 time steps simulated\nInfo: 6000000 time steps simulated\nInfo: 6100000 time steps simulated\nInfo: 6200000 time steps simulated\nInfo: 6300000 time steps simulated\nInfo: 6400000 time steps simulated\nInfo: 6500000 time steps simulated\nInfo: 6600000 time steps simulated\nInfo: 6700000 time steps simulated\nInfo: 6800000 time steps simulated\nInfo: 6900000 time steps simulated\nInfo: 7000000 time steps simulated\nInfo: 7100000 time steps simulated\nInfo: 7200000 time steps simulated\nInfo: 7300000 time steps simulated\nInfo: 7400000 time steps simulated\nInfo: 7500000 time steps simulated\nInfo: 7600000 time steps simulated\nInfo: 7700000 time steps simulated\nInfo: 7800000 time steps simulated\nInfo: 7900000 time steps simulated\nInfo: 8000000 time steps simulated\nInfo: 8100000 time steps simulated\nInfo: 8200000 time steps simulated\nInfo: 8300000 time steps simulated\nInfo: 8400000 time steps simulated\nInfo: 8500000 time steps simulated\nInfo: 8600000 time steps simulated\nInfo: 8700000 time steps simulated\nInfo: 8800000 time steps simulated\nInfo: 8900000 time steps simulated\nInfo: 9000000 time steps simulated\nInfo: 9100000 time steps simulated\nInfo: 9200000 time steps simulated\nInfo: 9300000 time steps simulated\nInfo: 9400000 time steps simulated\nInfo: 9500000 time steps simulated\nInfo: 9600000 time steps simulated\nInfo: 9700000 time steps simulated\nInfo: 9800000 time steps simulated\nInfo: 9900000 time steps simulated\nInfo: 10000000 time steps simulated\nInfo: 10100000 time steps simulated\nInfo: 10200000 time steps simulated\nInfo: 10300000 time steps simulated\nInfo: 10400000 time steps simulated\nInfo: 10500000 time steps simulated\nInfo: 10600000 time steps simulated\nInfo: 10700000 time steps simulated\nInfo: 10800000 time steps simulated\nInfo: 10900000 time steps simulated\nInfo: 11000000 time steps simulated\nInfo: 11100000 time steps simulated\nInfo: 11200000 time steps simulated\nInfo: 11300000 time steps simulated\nInfo: 11400000 time steps simulated\nInfo: 11500000 time steps simulated\nInfo: 11600000 time steps simulated\nInfo: 11700000 time steps simulated\nInfo: 11800000 time steps simulated\nInfo: 11900000 time steps simulated\nInfo: 12000000 time steps simulated\nInfo: 12100000 time steps simulated\nInfo: 12200000 time steps simulated\nInfo: 12300000 time steps simulated\nInfo: 12400000 time steps simulated\nInfo: 12500000 time steps simulated\nInfo: 12600000 time steps simulated\nInfo: 12700000 time steps simulated\nInfo: 12800000 time steps simulated\nInfo: 12900000 time steps simulated\nInfo: 13000000 time steps simulated\nInfo: 13100000 time steps simulated\nInfo: 13200000 time steps simulated\nInfo: 13300000 time steps simulated\nInfo: 13400000 time steps simulated\nInfo: 13500000 time steps simulated\nInfo: 13600000 time steps simulated\nInfo: 13700000 time steps simulated\nInfo: 13800000 time steps simulated\nInfo: 13900000 time steps simulated\nInfo: 14000000 time steps simulated\nInfo: 14100000 time steps simulated\nInfo: 14200000 time steps simulated\nInfo: 14300000 time steps simulated\nInfo: 14400000 time steps simulated\nInfo: 14500000 time steps simulated\nInfo: 14600000 time steps simulated\nInfo: 14700000 time steps simulated\nInfo: 14800000 time steps simulated\nInfo: 14900000 time steps simulated\nInfo: 15000000 time steps simulated\nInfo: 15100000 time steps simulated\nInfo: 15200000 time steps simulated\nInfo: 15300000 time steps simulated\nInfo: 15400000 time steps simulated\nInfo: 15500000 time steps simulated\nInfo: 15600000 time steps simulated\nInfo: 15700000 time steps simulated\nInfo: 15800000 time steps simulated\nInfo: 15900000 time steps simulated\nInfo: 16000000 time steps simulated\nInfo: 16100000 time steps simulated\nInfo: 16200000 time steps simulated\nInfo: 16300000 time steps simulated\nInfo: 16400000 time steps simulated\nInfo: 16500000 time steps simulated\nInfo: 16600000 time steps simulated\nInfo: 16700000 time steps simulated\nInfo: 16800000 time steps simulated\nInfo: 16900000 time steps simulated\nInfo: 17000000 time steps simulated\nInfo: 17100000 time steps simulated\nInfo: 17200000 time steps simulated\nInfo: 17300000 time steps simulated\nInfo: 17400000 time steps simulated\nInfo: 17500000 time steps simulated\nInfo: 17600000 time steps simulated\nInfo: 17700000 time steps simulated\nInfo: 17800000 time steps simulated\nInfo: 17900000 time steps simulated\nInfo: 18000000 time steps simulated\nInfo: 18100000 time steps simulated\nInfo: 18200000 time steps simulated\nInfo: 18300000 time steps simulated\nInfo: 18400000 time steps simulated\nInfo: 18500000 time steps simulated\nInfo: 18600000 time steps simulated\nInfo: 18700000 time steps simulated\nInfo: 18800000 time steps simulated\nInfo: 18900000 time steps simulated\nInfo: 19000000 time steps simulated\nInfo: 19100000 time steps simulated\nInfo: 19200000 time steps simulated\nInfo: 19300000 time steps simulated\nInfo: 19400000 time steps simulated\nInfo: 19500000 time steps simulated\nInfo: 19600000 time steps simulated\nInfo: 19700000 time steps simulated\nInfo: 19800000 time steps simulated\nInfo: 19900000 time steps simulated\nInfo: 20000000 time steps simulated\nInfo: 20100000 time steps simulated\nInfo: 20200000 time steps simulated\nInfo: 20300000 time steps simulated\nInfo: 20400000 time steps simulated\nInfo: 20500000 time steps simulated\nInfo: 20600000 time steps simulated\nInfo: 20700000 time steps simulated\nInfo: 20800000 time steps simulated\nInfo: 20900000 time steps simulated\nInfo: 21000000 time steps simulated\nInfo: 21100000 time steps simulated\nInfo: 21200000 time steps simulated\nInfo: 21300000 time steps simulated\nInfo: 21400000 time steps simulated\nInfo: 21500000 time steps simulated\nInfo: 21600000 time steps simulated\nInfo: 21700000 time steps simulated\nInfo: 21800000 time steps simulated\nInfo: Simulation time 13.30178\n\n\n\n\n\nSpecies \\(R\\) probability mass is concentrated at lower values, while species \\(R\\) and \\(S\\) have a more uniform distribution.\nComputing mean and standard deviation of the species copy number is not straightforward as the time between two events is not constant, thus it is necessary to track the time spent in each state for each species. This computation is implemented by the following functions:\n\n\nCode\nsmod.PrintSpeciesMeans()\nsmod.PrintSpeciesStandardDeviations()\n\n\nSpecies Mean\nR   53.108\nS   28.366\nP   18.526\nSpecies Standard Deviation\nR   23.734\nS   19.751\nP   18.520\n\n\nSpecies mean copy number is close to the fixed point.\nWe can also experiment with delayed reactions, consisting of an exponential waiting time as initiation step with a subsequent delay time. We set a fixed delay of five seconds on reaction \\(R1\\) (\\(R + S \\rightarrow 2R\\)). This means that after \\(R1\\) fires, it takes exactly five seconds before products are produced. By setting nonconsuming_reactions=[\"R1\"], reactants are consumed at completion.\n\n\nCode\nsmod.SetDelayParameters({\"R1\":(\"fixed\",5)}, nonconsuming_reactions=[\"R1\"])\nsmod.DoDelayedStochSim(mode=\"time\", end=10, trajectories=100)\nsmod.PlotAverageSpeciesTimeSeries()\n\n\n*** WARNING ***: an invalid method (Direct) was selected. Switching to the Delayed Direct Method.\nInfo: Delayed Direct Method is selected to perform delayed stochastic simulations.\nParsing file: ../long_range_models/RSP_model_reduced.psc\nInfo: No reagents have been fixed\nInfo: 100 trajectories are generated\nInfo: Time simulation output of the trajectories is stored at RSP_model_reduced(trajectory).dat in directory: /Users/irenetesta/Stochpy/temp\nInfo: Simulation time: 17.422198057174683                                                   *** WARNING ***: No regular grid is created yet. Use GetRegularGrid(n_samples) if averaged results are unsatisfactory (e.g. more or less 'samples')\n\n\n\n\n\nIf \\(R1\\) is delayed, after the first five seconds, the system will reach the absorbing state where only species \\(R\\) is present.\nPerforming a stochastic simulation with equal initial population densities:\n\n\nCode\nsmod.SetDelayParameters({})\nsmod.ChangeInitialSpeciesCopyNumber(\"R\", 33)\nsmod.ChangeInitialSpeciesCopyNumber(\"S\", 33)\nsmod.ChangeInitialSpeciesCopyNumber(\"P\", 33)\nsmod.DoStochSim(end=1000, method=\"direct\")\nsmod.PlotSpeciesTimeSeries(colors=[\"tab:red\", \"purple\", \"gold\"], xlabel=\"Steps\")\nstochpy.plt.title(\"$P_r=0.2$, $P_s=0.5$, $P_p=0.3$, $R=33$, $S=33$, $P=33$\");\n\n\nInfo: Direct method is selected to perform stochastic simulations.\nParsing file: ../long_range_models/RSP_model_reduced.psc\nInfo: No reagents have been fixed\nInfo: 1 trajectory is generated\nsimulation done!               \nInfo: Number of time steps 469 End time 1.0884810590458118\nInfo: Simulation time 0.00356\n\n\n\n\n\nDifferently from the simulation with ODEs, the system does not exhibit sustained oscillations, as the inherent randomness in the timing and sequence of reactions introduces fluctuations that prevent the emergence of periodic behavior.\n\nGenetic Network with Negative Feedback Loop\nA suitable case study for stochastic simulations is a genetic network consisting of a feedback loop involving three genes. In this system, each gene encodes a protein that represses the expression of the subsequent gene in the loop, similar to the dynamics seen in a rock-paper-scissors game.\n\\[\\begin{cases}\nG_1 \\xrightarrow{r_{P_1}} G_1 + P_1\\quad (1)\\\\\nG_2 \\xrightarrow{r_{P_2}} G_2 + P_2\\quad (2)\\\\\nG_3 \\xrightarrow{r_{P_3}} G_3 + P_3\\quad (3)\\\\\nP_1 + G_2 \\underset{r_{U_1}}{\\xrightleftharpoons{r_{B_1}}} P_1G_2\\quad (4)\\\\\nP_2 + G_3 \\underset{r_{U_2}}{\\xrightleftharpoons{r_{B_2}}} P_2G_3\\quad (5)\\\\\nP_3 + G_1 \\underset{r_{U_3}}{\\xrightleftharpoons{r_{B_3}}} P_3G_1\\quad (6)\\\\\nP_1 \\xrightarrow{r_{D_1}}\\quad (7)\\\\\nP_2 \\xrightarrow{r_{D_2}}\\quad (8)\\\\\nP_3 \\xrightarrow{r_{D_3}}\\quad (9)\\\\\n\\end{cases}\\]\nIn this network, each gene produces a protein (reactions \\((1), (2), (3)\\)), which can interact with the next gene in the loop to inhibit its expression (reactions \\((4), (5), (6)\\), forward reactions). This inhibition creates a negative feedback loop, as each protein suppresses the activity of the subsequent gene in the sequence. The inhibition occurs when the protein binds to the gene, preventing it from synthesizing its associated protein. However, the protein-gene complex can dissociate, freeing the gene to resume protein production (reactions \\((4), (5), (6)\\), reverse reactions). Additionally, over time, the proteins degrade and disappear from the system (reactions \\((7), (8), (9)\\)).\nVisualizing the model in the PySCeS MDL format:\n\n\nCode\n!cat ../long_range_models/negative_feedback_loop_model.psc\n\n\n# Negative feedback loop\n\n# G1 --&gt; RP1, G1 + P1\n# G2 --&gt; RP2, G2 + P2\n# G3 --&gt; RP2, G3 + P3\n# P1 + G2, RU1 &lt;--&gt; RB1, P1G2\n# P2 + G3, RU2 &lt;--&gt; RB2, P2G3\n# P3 + G1, RU3 &lt;--&gt; RB3, P3G1\n# P1 --&gt; RD1,\n# P2 --&gt; RD2,\n# P3 --&gt; RD3,\n\nR1:\n    G1 &gt; G1 + P1\n    G1*RP1\n\nR2:\n    G2 &gt; G2 + P2\n    G2*RP2\n\nR3:\n    G3 &gt; G3 + P3\n    G3*RP3\n\nR4:\n    P1 + G2 &gt; P1G2\n    P1*G2*RB1\n\nR5:\n    P1G2 &gt; P1 + G2\n    P1G2*RU1\n\nR6:\n    P2 + G3 &gt; P2G3\n    P2*G3*RB2\n\nR7:\n    P2G3 &gt; P2 + G3\n    P2G3*RU2\n\nR8:\n    P3 + G1 &gt; P3G1\n    P3*G1*RB3\n\nR9:\n    P3G1 &gt; P3 + G1\n    P3G1*RU3\n\nR10:\n    P1 &gt; $pool\n    P1*RD1\n\nR11:\n    P2 &gt; $pool\n    P2*RD2\n\nR12:\n    P3 &gt; $pool\n    P3*RD3\n\n# Parameters\nRP1 = 10\nRP2 = 10000\nRP3 = 10\nRB1 = 10\nRU1 = 2\nRB2 = 0.1\nRU2 = 20\nRB3 = 10\nRU3 = 20\nRD1 = 1\nRD2 = 100\nRD3 = 1\n\n# Init Values\nP1 = 0\nP2 = 0\nP3 = 0\nG1 = 1\nG2 = 1\nG3 = 1\nP1G2 = 0\nP2G3 = 0\nP3G1 = 0\n\n\nThe system is initialized with a copy of each gene, no proteins and no protein-gene complexes. The reaction rates are set so that \\(G2\\) produces its protein much more rapidly, and this protein has a shorter lifespan, degrading at a faster rate.\nLoading the model into StochPy and performing a stochastic simulation:\n\n\nCode\nsmod = stochpy.SSA(IsQuiet=False)\nsmod.Model(model_file=\"negative_feedback_loop_model.psc\",dir=\"../long_range_models/\")\nsmod.DoStochSim(IsTrackPropensities=True, end=10000)\n\n\nInfo: Direct method is selected to perform stochastic simulations.\nParsing file: /Users/irenetesta/Stochpy/pscmodels/ImmigrationDeath.psc\nInfo: No reagents have been fixed\nParsing file: ../long_range_models/negative_feedback_loop_model.psc\nInfo: No reagents have been fixed\nInfo: 1 trajectory is generated\nsimulation done!               \nInfo: Number of time steps 10000 End time 6.3121454739530645\nInfo: Simulation time 0.12413\n\n\nVisualizing the evolution of the system:\n\n\nCode\nnfl_stoch_df = pd.DataFrame(smod.data_stochsim.species, columns=smod.data_stochsim.species_labels)\nnfl_stoch_df[['P1', 'P2', 'P3']].plot(figsize=(20,5), color=['red', 'green', 'blue'], xlabel=\"Steps\", ylabel=\"Copy number\", title=\"Proteins\")\nnfl_stoch_df[['P3G1', 'G1']].plot(figsize=(20,5), color=['black', 'darkturquoise'], xlabel=\"Steps\", ylabel=\"Copy number\", title=\"G1 inhibition\")\nnfl_stoch_df[['P1G2', 'G2']].plot(figsize=(20,5), color=['black', 'magenta'], xlabel=\"Steps\", ylabel=\"Copy number\", title=\"G2 inhibition\")\nnfl_stoch_df[['P2G3', 'G3']].plot(figsize=(20,5), color=['black', 'gold'], xlabel=\"Steps\", ylabel=\"Copy number\", title=\"G3 inhibition\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe production of \\(P2\\) exhibits valleys, where the protein is not produced, corresponding to the presence of the \\(P1G2\\) protein-gene complex.\nIf we adopt the continuous time approach and solve the corresponding system of ODEs, i.e.\n\\[\\begin{cases}\n\\frac{\\partial G_1}{\\partial t}=-r_{B_3} \\cdot P_3\\cdot G_1 + r_{U_3} \\cdot P_3G_1\\\\\n\\frac{\\partial G_2}{\\partial t}=-r_{B_1} \\cdot P_1\\cdot G_2 + r_{U_1} \\cdot P_1G_2\\\\\n\\frac{\\partial G_3}{\\partial t}=-r_{B_2} \\cdot P_2\\cdot G_3 + r_{U_2} \\cdot P_2G_3\\\\\\\n\\frac{\\partial P_1}{\\partial t}=r_{P_1}\\cdot G_1 - r_{B_1} \\cdot P_1\\cdot G_2 + r_{U_1}\\cdot P_1G_2 - r_{D_1}\\cdot P_1\\\\\n\\frac{\\partial P_2}{\\partial t}=r_{P_2}\\cdot G_2- r_{B_2}\\cdot P_2\\cdot G_3+r_{U_2}\\cdot P_2G_3-r_{D_2}\\cdot P_2\\\\\n\\frac{\\partial P_3}{\\partial t}=r_{P_3}\\cdot G_3- r_{B_3}\\cdot P_3\\cdot G_1 +r_{U_3} \\cdot P_3G_1-r_{D_3}\\cdot P_3\\\\\n\\frac{\\partial P_1G_2}{\\partial t}=r_{B_1}\\cdot P_1\\cdot G_2 - r_{U_1} \\cdot P_1G_2\\\\\n\\frac{\\partial P_2G_3}{\\partial t}=r_{B_2}\\cdot P_2\\cdot G_3 - r_{U_2}\\cdot P_2G_3\\\\\n\\frac{\\partial P_3G_1}{\\partial t}=r_{B_3}\\cdot P_3\\cdot G_1 - r_{U_3} \\cdot P_3G_1\\\\\n\\end{cases}\\]\nial P_3G_1}{t}=r_{B_3}P_3G_1 - r_{U_3} P_3G_1\\ \\end{cases}\nwe would allow molecules to assume continuous values, meaning that genes and protein-gene complexes could take on values between \\(0\\) and \\(1\\), which does not accurately reflect the discrete nature of the system.\nDefining a function to simulate the evolution of the system in the continuous setting:\n\n\nCode\ndef NFL_ODE_solver(t, rates, init):\n    '''\n    Solve the initial value problem for ODE system modeling the genetic network with negative feedback loop.\n    '''\n    def neg_feedback_loop(x0, t, rates):\n        G1, G2, G3, P1, P2, P3, P1G2, P2G3, P3G1 = x0\n        d_G1_dt = -rates['rB3']*P3*G1 + rates['rU3']*P3G1\n        d_G2_dt = -rates['rB1']*P1*G2 + rates['rU1']*P1G2\n        d_G3_dt = -rates['rB2']*P2*G3 + rates['rU2']*P2G3\n        d_P1_dt = +rates['rP1']*G1 - rates['rB1']*P1*G2 + rates['rU1']*P1G2 - rates['rD1']*P1\n        d_P2_dt = +rates['rP2']*G2 - rates['rB2']*P2*G3 + rates['rU2']*P2G3 - rates['rD2']*P2\n        d_P3_dt = +rates['rP3']*G3 - rates['rB3']*P3*G1 + rates['rU3']*P3G1 - rates['rD3']*P3\n        d_P1G2_dt = +rates['rB1']*P1*G2 - rates['rU1']*P1G2\n        d_P2G3_dt = +rates['rB2']*P2*G3 - rates['rU2']*P2G3\n        d_P3G1_dt = +rates['rB3']*P3*G1 - rates['rU3']*P3G1\n        return [d_G1_dt, d_G2_dt, d_G3_dt, d_P1_dt, d_P2_dt, d_P3_dt, d_P1G2_dt, d_P2G3_dt, d_P3G1_dt]\n\n    x0 = [init['G1'], init['G2'], init['G3'], init['P1'], init['P2'], init['P3'], init['P1G2'], init['P2G3'], init['P3G1']]\n    y = odeint(neg_feedback_loop, x0, t, args=(rates,))\n    results_df = pd.DataFrame(y, columns=['$G_1$', '$G_2$', '$G_3$', '$P_1$', '$P_2$', '$P_3$', '$P_1G_2$', '$P_2G_3$', '$P_3G_1$'])\n    return results_df\n\n\nSimulate the system for 50 time units:\n\n\nCode\nnfl_rates = {\n    'rP1': 10,\n    'rP2': 10000,\n    'rP3': 10,\n    'rB1': 10,\n    'rB2': 0.1,\n    'rB3': 10,\n    'rU1': 2,\n    'rU2': 20,\n    'rU3': 20,\n    'rD1': 1,\n    'rD2': 100,\n    'rD3': 1\n}\nnfl_init = {\n    'G1': 1,\n    'G2': 1,\n    'G3': 1,\n    'P1': 0,\n    'P2': 0,\n    'P3': 0,\n    'P1G2': 0,\n    'P2G3': 0,\n    'P3G1': 0\n}\nnfl_cont_df = NFL_ODE_solver(np.linspace(0,50,51), nfl_rates, nfl_init)\nnfl_cont_df[['$P_1$', '$P_2$', '$P_3$']].plot(figsize=(20,5), color=['red', 'green', 'blue'], xlabel=\"Time\", ylabel=\"Value\", title=\"Proteins\")\nnfl_cont_df[['$P_3G_1$', '$G_1$']].plot(figsize=(20,5), color=['black', 'darkturquoise'], xlabel=\"Time\", ylabel=\"Value\", title=\"G1 inhibition\")\nnfl_cont_df[['$P_1G_2$', '$G_2$']].plot(figsize=(20,5), color=['black', 'magenta'], xlabel=\"Time\", ylabel=\"Value\", title=\"G2 inhibition\")\nnfl_cont_df[['$P_2G_3$', '$G_3$']].plot(figsize=(20,5), color=['black', 'gold'], xlabel=\"Time\", ylabel=\"Value\", title=\"G3 inhibition\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIndeed, this simulation shows a completely different behavior. Over time, the negative feedback loop stabilizes the levels of all proteins, leading the system to reach a steady state. This dynamic does not occur in nature, as the system is inherently stochastic and discrete.\n\n\n\n4. Stochastic model checking\nStochastic model checking enables the verification of properties in stochastic systems by quantifying their probabilities through systematic exploration of all possible system behaviors.\nTo perform stochastic model checking we need to translate the model into a Continuous Time Markov Chain (CTMC) and specify the properties we want to verify. Dynamical properties of the resulting CTMC could then be analyzed using the stochastic model checker PRISM.\nPRISM represents CTMC states using a set of bounded integer variables, necessitating the assumption of a discrete state space. This results in the following CTMC specification in PRISM’s input language (stored in the file ../long_range_models/RSP.prism), where model parameters are defined by Pr, Ps and Pp constants (initialized with the same values used in the previous simulations), MAX is the maximum number of molecules per species (set to 100 due to the prohibitive computational time required for higher values) and we have three transitions describing the three possible reactions:\n\n\nCode\n!cat ../long_range_models/RSP.prism\n\n\nctmc\n\nconst double Pr = 0.2;\nconst double Ps = 0.5;\nconst double Pp = 0.3;\n\nconst int MAX = 100;\n\nmodule RSP\n\n  r : [0..MAX] init 50;\n  s : [0..MAX] init 30;\n  p : [0..MAX] init 20;\n\n  [] r&gt;0 & r&lt;MAX & s&gt;0 -&gt; Pr*r*s : (r'=r+1) & (s'=s-1);\n  [] s&gt;0 & s&lt;MAX & p&gt;0 -&gt; Ps*s*p : (s'=s+1) & (p'=p-1);\n  [] p&gt;0 & p&lt;MAX & r&gt;0 -&gt; Pp*p*r : (p'=p+1) & (r'=r-1);\n\nendmodule\n\n\nNoting that r + s + p = 1, we can simplify the model to reduce computational time by eliminating the variable p. This results in the following PRISM input:\n\n\nCode\n!cat ../long_range_models/RSP_reduced.prism\n\n\nctmc\n\nconst double Pr = 0.2;\nconst double Ps = 0.5;\nconst double Pp = 0.3;\n\nconst int MAX = 100;\n\nmodule RSP\n\n  r : [0..MAX] init 50;\n  s : [0..MAX] init 30;\n\n  [] r&gt;0 & r&lt;MAX & s&gt;0 -&gt; Pr*r*s : (r'=r+1) & (s'=s-1);\n  [] s&gt;0 & s&lt;MAX & (MAX-r-s)&gt;0 -&gt; Ps*s*(MAX-r-s) : (s'=s+1);\n  [] (MAX-r-s)&gt;0 & (MAX-r-s)&lt;MAX & r&gt;0 -&gt; Pp*(MAX-r-s)*r : (r'=r-1);\n\nendmodule\n\n\nLet’s visualize the graphical representation of the CTMC (that can be exported from PRISM) for a system with MAX=10:\n\n\nCode\nwith open('../results/ctmc.dot', 'r') as file:\n    dot_data = file.read()\ngraph = Source(dot_data)\ngraph\n\n\n\n\n\nThe initial state of the system is state 48, where all exit rates are equal to 3, corresponding to the equilibrium point.\nWe can define a list of properties to be verified, using the CSL temporal logic:\n\n\nCode\n!cat ../long_range_models/RSP_properties.csl\n\n\nP=?[ F r=0 ]\n\nP=?[ F s=0 ]\n\nP=?[ F (MAX-r-s)=0 ]\n\nP=?[ F (r=70 & (F r=0)) ]\n\nP=?[ F (s=70 & (F s=0)) ]\n\nP=?[ F ((MAX-r-s)=70 & (F (MAX-r-s)=0)) ]\n\nP=?[ F (MAX-r-s)=0 & s=0 ]\n\nP=?[ F s=0 & r=0 ]\n\nP=?[ F r=0 & (MAX-r-s)=0 ]\n\nconst int time;\n\nP=? [ F&lt;time r=0 ]\n\nP=? [ F&lt;time s=0 ]\n\nP=? [ F&lt;time (MAX-r-s)=0 ]\n\nP=? [F&lt;time (r=0 | r=MAX | s=0) & (s=0 | s=MAX | (MAX-r-s)=0) & ((MAX-r-s)=0 | (MAX-r-s)=MAX | r=0)]\n\nconst int x;\n\nP=? [ F=1 r&gt;=x & r&lt;x+10 ]\n\nP=? [ F=1 s&gt;=x & s&lt;x+10 ]\n\nP=? [ F=1 (MAX-r-s)&gt;=x & (MAX-r-s)&lt;x+10 ]\n\n\nand then use PRISM to verify these properties. PRISM saves the results in a log file, which we can load and analyze:\n\n\nCode\n!sed -n '9,128p' ../results/prism_log.txt\n\n\nType:        CTMC\nModules:     RSP\nVariables:   r s\n\n---------------------------------------------------------------------\n\nModel checking: P=? [ F r=0 ]\n\nBuilding model...\n\nComputing reachable states...\n\nReachability (BFS): 121 iterations in 0.00 seconds (average 0.000000, setup 0.00)\n\nTime for model construction: 0.124 seconds.\n\nWarning: Deadlocks detected and fixed in 3 states\n\nType:        CTMC\nStates:      5151 (1 initial)\nTransitions: 14853\n\nRate matrix: 44090 nodes (3611 terminal), 14853 minterms, vars: 14r/14c\n\nDiagonals vector: 7997 nodes (2482 terminal), 5151 minterms\nEmbedded Markov chain: 72269 nodes (13625 terminal), 14853 minterms\n\nProb0: 100 iterations in 0.03 seconds (average 0.000310, setup 0.00)\n\nProb1: 99 iterations in 0.06 seconds (average 0.000626, setup 0.00)\n\nyes = 200, no = 100, maybe = 4851\n\nComputing remaining probabilities...\nEngine: Hybrid\n\nBuilding hybrid MTBDD matrix... [levels=14, nodes=72180] [3.3 MB]\nAdding explicit sparse matrices... [levels=14, num=1, compact] [168.3 KB]\nCreating vector for diagonals... [dist=1, compact] [10.1 KB]\nCreating vector for RHS... [dist=2, compact] [10.1 KB]\nAllocating iteration vectors... [2 x 40.2 KB]\nTOTAL: [3.6 MB]\n\nStarting iterations...\n\nJacobi: 5067 iterations in 4.03 seconds (average 0.000043, setup 3.81)\n\nValue in the initial state: 0.1412982989479114\n\nTime for model checking: 5.41 seconds.\n\nResult: 0.1412982989479114 (+/- 1.4120125376176834E-6 estimated; rel err 9.993131892820674E-6)\n\n---------------------------------------------------------------------\n\nModel checking: P=? [ F s=0 ]\n\nDiagonals vector: 7997 nodes (2482 terminal), 5151 minterms\nEmbedded Markov chain: 72269 nodes (13625 terminal), 14853 minterms\n\nProb0: 100 iterations in 0.06 seconds (average 0.000620, setup 0.00)\n\nProb1: 99 iterations in 0.02 seconds (average 0.000162, setup 0.00)\n\nyes = 200, no = 100, maybe = 4851\n\nComputing remaining probabilities...\nEngine: Hybrid\n\nBuilding hybrid MTBDD matrix... [levels=14, nodes=72180] [3.3 MB]\nAdding explicit sparse matrices... [levels=14, num=1, compact] [168.3 KB]\nCreating vector for diagonals... [dist=1, compact] [10.1 KB]\nCreating vector for RHS... [dist=2, compact] [10.1 KB]\nAllocating iteration vectors... [2 x 40.2 KB]\nTOTAL: [3.6 MB]\n\nStarting iterations...\n\nJacobi: 5098 iterations in 2.55 seconds (average 0.000022, setup 2.44)\n\nValue in the initial state: 0.9829185886675442\n\nTime for model checking: 5.287 seconds.\n\nResult: 0.9829185886675442 (+/- 9.824397199114573E-6 estimated; rel err 9.995128093398498E-6)\n\n---------------------------------------------------------------------\n\nModel checking: P=? [ F (MAX-r-s)=0 ]\n\nDiagonals vector: 7997 nodes (2482 terminal), 5151 minterms\nEmbedded Markov chain: 72269 nodes (13625 terminal), 14853 minterms\n\nProb0: 100 iterations in 0.08 seconds (average 0.000780, setup 0.00)\n\nProb1: 99 iterations in 0.00 seconds (average 0.000000, setup 0.00)\n\nyes = 200, no = 100, maybe = 4851\n\nComputing remaining probabilities...\nEngine: Hybrid\n\nBuilding hybrid MTBDD matrix... [levels=14, nodes=72180] [3.3 MB]\nAdding explicit sparse matrices... [levels=14, num=1, compact] [168.3 KB]\nCreating vector for diagonals... [dist=1, compact] [10.1 KB]\nCreating vector for RHS... [dist=2, compact] [10.1 KB]\nAllocating iteration vectors... [2 x 40.2 KB]\nTOTAL: [3.6 MB]\n\nStarting iterations...\n\nJacobi: 5108 iterations in 2.09 seconds (average 0.000028, setup 1.95)\n\nValue in the initial state: 0.8745308920684021\n\nTime for model checking: 5.281 seconds.\n\nResult: 0.8745308920684021 (+/- 8.735542417834342E-6 estimated; rel err 9.988832295190192E-6)\n\n---------------------------------------------------------------------\n\n\nBy inspecting the log file, we can see that the model has \\(5151\\) states and \\(14853\\) transitions.\nThe probabilities of extinction for species r, s, and p are \\(0.14\\), \\(0.98\\), and \\(0.87\\), respectively. Again, the population with the lowest invasion rate is the least likely to become extinct.\nLoading subsequent lines of PRISM log file:\n\n\nCode\n!sed -n '128,278p' ../results/PRISM_log.txt\n\n\n---------------------------------------------------------------------\n\nModel checking: P=? [ F (r=70&(F r=0)) ]\n\nBuilding deterministic automaton (for F (\"L0\"&(F \"L1\")))...\nDFA has 3 states, 1 goal states.\nTime for deterministic automaton translation: 0.03 seconds.\n\nConstructing MC-DFA product...\n\nReachability (BFS): 181 iterations in 0.05 seconds (average 0.000260, setup 0.00)\n\nStates:      9806 (1 initial)\nTransitions: 28340\n\nTransition matrix: 44164 nodes (3611 terminal), 28340 minterms, vars: 16r/16c\n\nSkipping BSCC computation since acceptance is defined via goal states...\n\nComputing reachability probabilities...\n\nDiagonals vector: 8037 nodes (2485 terminal), 9806 minterms\nEmbedded Markov chain: 72343 nodes (13625 terminal), 28340 minterms\n\nProb0: 208 iterations in 0.06 seconds (average 0.000303, setup 0.00)\n\nProb1: 99 iterations in 0.11 seconds (average 0.001101, setup 0.00)\n\nyes = 200, no = 339, maybe = 9267\n\nComputing remaining probabilities...\nEngine: Hybrid\n\nBuilding hybrid MTBDD matrix... [levels=16, nodes=72279] [3.3 MB]\nAdding explicit sparse matrices... [levels=16, num=1, compact] [224.6 KB]\nCreating vector for diagonals... [dist=1, compact] [19.2 KB]\nCreating vector for RHS... [dist=2, compact] [19.2 KB]\nAllocating iteration vectors... [2 x 76.6 KB]\nTOTAL: [3.7 MB]\n\nStarting iterations...\n\nJacobi: 5067 iterations in 4.00 seconds (average 0.000117, setup 3.41)\n\nValue in the initial state: 0.1412860009175909\n\nTime for model checking: 5.828 seconds.\n\nResult: 0.1412860009175909\n\n---------------------------------------------------------------------\n\nModel checking: P=? [ F (s=70&(F s=0)) ]\n\nBuilding deterministic automaton (for F (\"L0\"&(F \"L1\")))...\nDFA has 3 states, 1 goal states.\nTime for deterministic automaton translation: 0.0 seconds.\n\nConstructing MC-DFA product...\n\nReachability (BFS): 231 iterations in 0.08 seconds (average 0.000338, setup 0.00)\n\nStates:      9806 (1 initial)\nTransitions: 28340\n\nTransition matrix: 51284 nodes (3611 terminal), 28340 minterms, vars: 16r/16c\n\nSkipping BSCC computation since acceptance is defined via goal states...\n\nComputing reachability probabilities...\n\nDiagonals vector: 9513 nodes (2483 terminal), 9806 minterms\nEmbedded Markov chain: 78314 nodes (13625 terminal), 28340 minterms\n\nProb0: 208 iterations in 0.05 seconds (average 0.000226, setup 0.00)\n\nProb1: 99 iterations in 0.02 seconds (average 0.000162, setup 0.00)\n\nyes = 200, no = 339, maybe = 9267\n\nComputing remaining probabilities...\nEngine: Hybrid\n\nBuilding hybrid MTBDD matrix... [levels=16, nodes=83010] [3.8 MB]\nAdding explicit sparse matrices... [levels=16, num=1, compact] [224.6 KB]\nCreating vector for diagonals... [dist=1, compact] [19.2 KB]\nCreating vector for RHS... [dist=2, compact] [19.2 KB]\nAllocating iteration vectors... [2 x 76.6 KB]\nTOTAL: [4.2 MB]\n\nStarting iterations...\n\nJacobi: 5289 iterations in 3.28 seconds (average 0.000098, setup 2.77)\n\nValue in the initial state: 0.6506808914402584\n\nTime for model checking: 6.768 seconds.\n\nResult: 0.6506808914402584\n\n---------------------------------------------------------------------\n\nModel checking: P=? [ F ((MAX-r-s)=70&(F (MAX-r-s)=0)) ]\n\nBuilding deterministic automaton (for F (\"L0\"&(F \"L1\")))...\nDFA has 3 states, 1 goal states.\nTime for deterministic automaton translation: 0.008 seconds.\n\nConstructing MC-DFA product...\n\nReachability (BFS): 221 iterations in 0.03 seconds (average 0.000140, setup 0.00)\n\nStates:      9806 (1 initial)\nTransitions: 28340\n\nTransition matrix: 50473 nodes (3611 terminal), 28340 minterms, vars: 16r/16c\n\nSkipping BSCC computation since acceptance is defined via goal states...\n\nComputing reachability probabilities...\n\nDiagonals vector: 9522 nodes (2485 terminal), 9806 minterms\nEmbedded Markov chain: 78216 nodes (13625 terminal), 28340 minterms\n\nProb0: 208 iterations in 0.05 seconds (average 0.000226, setup 0.00)\n\nProb1: 99 iterations in 0.05 seconds (average 0.000475, setup 0.00)\n\nyes = 200, no = 339, maybe = 9267\n\nComputing remaining probabilities...\nEngine: Hybrid\n\nBuilding hybrid MTBDD matrix... [levels=16, nodes=81568] [3.7 MB]\nAdding explicit sparse matrices... [levels=16, num=1, compact] [224.6 KB]\nCreating vector for diagonals... [dist=1, compact] [19.2 KB]\nCreating vector for RHS... [dist=2, compact] [19.2 KB]\nAllocating iteration vectors... [2 x 76.6 KB]\nTOTAL: [4.1 MB]\n\nStarting iterations...\n\nJacobi: 5386 iterations in 2.36 seconds (average 0.000038, setup 2.16)\n\nValue in the initial state: 0.28962347433238994\n\nTime for model checking: 6.576 seconds.\n\nResult: 0.28962347433238994\n\n---------------------------------------------------------------------\n\n\nThe probability of a species to go extinct after having reached a density of \\(0.7\\) is \\(0.14\\) for species r, \\(0.65\\) for species s, and \\(0.29\\) for species p. If species sand p reach a density of \\(0.7\\), they are less likely to become extinct in the future as compared to the extinction probability of these species from the initial state.\nLoading subsequent lines of PRISM log file:\n\n\nCode\n!sed -n '278,375p' ../results/PRISM_log.txt\n\n\n---------------------------------------------------------------------\n\nModel checking: P=? [ F s=0&r=0 ]\n\nDiagonals vector: 7997 nodes (2482 terminal), 5151 minterms\nEmbedded Markov chain: 72269 nodes (13625 terminal), 14853 minterms\n\nProb0: 198 iterations in 0.05 seconds (average 0.000237, setup 0.00)\n\nProb1: 50 iterations in 0.01 seconds (average 0.000300, setup 0.00)\n\nyes = 100, no = 200, maybe = 4851\n\nComputing remaining probabilities...\nEngine: Hybrid\n\nBuilding hybrid MTBDD matrix... [levels=14, nodes=72180] [3.3 MB]\nAdding explicit sparse matrices... [levels=14, num=1, compact] [168.3 KB]\nCreating vector for diagonals... [dist=1, compact] [10.1 KB]\nCreating vector for RHS... [dist=2, compact] [10.1 KB]\nAllocating iteration vectors... [2 x 40.2 KB]\nTOTAL: [3.6 MB]\n\nStarting iterations...\n\nJacobi: 5060 iterations in 2.31 seconds (average 0.000015, setup 2.23)\n\nValue in the initial state: 0.12484498983774625\n\nTime for model checking: 5.309 seconds.\n\nResult: 0.12484498983774625 (+/- 1.2472498654345966E-6 estimated; rel err 9.990387816568165E-6)\n\n---------------------------------------------------------------------\n\nModel checking: P=? [ F r=0&(MAX-r-s)=0 ]\n\nDiagonals vector: 7997 nodes (2482 terminal), 5151 minterms\nEmbedded Markov chain: 72269 nodes (13625 terminal), 14853 minterms\n\nProb0: 198 iterations in 0.00 seconds (average 0.000000, setup 0.00)\n\nProb1: 50 iterations in 0.01 seconds (average 0.000300, setup 0.00)\n\nyes = 100, no = 200, maybe = 4851\n\nComputing remaining probabilities...\nEngine: Hybrid\n\nBuilding hybrid MTBDD matrix... [levels=14, nodes=72180] [3.3 MB]\nAdding explicit sparse matrices... [levels=14, num=1, compact] [168.3 KB]\nCreating vector for diagonals... [dist=1, compact] [10.1 KB]\nCreating vector for RHS... [dist=2, compact] [10.1 KB]\nAllocating iteration vectors... [2 x 40.2 KB]\nTOTAL: [3.6 MB]\n\nStarting iterations...\n\nJacobi: 5141 iterations in 2.62 seconds (average 0.000030, setup 2.47)\n\nValue in the initial state: 0.01645373692597371\n\nTime for model checking: 5.285 seconds.\n\nResult: 0.01645373692597371 (+/- 1.6439874796782045E-7 estimated; rel err 9.991575087620501E-6)\n\n---------------------------------------------------------------------\n\nModel checking: P=? [ F (MAX-r-s)=0&s=0 ]\n\nDiagonals vector: 7997 nodes (2482 terminal), 5151 minterms\nEmbedded Markov chain: 72269 nodes (13625 terminal), 14853 minterms\n\nProb0: 198 iterations in 0.05 seconds (average 0.000237, setup 0.00)\n\nProb1: 50 iterations in 0.00 seconds (average 0.000000, setup 0.00)\n\nyes = 100, no = 200, maybe = 4851\n\nComputing remaining probabilities...\nEngine: Hybrid\n\nBuilding hybrid MTBDD matrix... [levels=14, nodes=72180] [3.3 MB]\nAdding explicit sparse matrices... [levels=14, num=1, compact] [168.3 KB]\nCreating vector for diagonals... [dist=1, compact] [10.1 KB]\nCreating vector for RHS... [dist=2, compact] [10.1 KB]\nAllocating iteration vectors... [2 x 40.2 KB]\nTOTAL: [3.6 MB]\n\nStarting iterations...\n\nJacobi: 5107 iterations in 1.92 seconds (average 0.000006, setup 1.89)\n\nValue in the initial state: 0.8580768529067467\n\nTime for model checking: 5.346 seconds.\n\nResult: 0.8580768529067467 (+/- 8.574549754478324E-6 estimated; rel err 9.992752660128196E-6)\n\n\nThe probability that each species will outcompete the other two (corresponding to an absorbing state, i.e. a state where no further transitions are possible) is \\(0.12\\) for species p, \\(0.02\\) for species s, and \\(0.86\\) for species r (since they sum to \\(1\\), the system will reach an absorbing state with certainty).\nBy varying the constant time between \\(1\\) and \\(10\\), we can plot the extinction probabilities for each species, i.e.:\nconst int time;\nP=? [ F&lt;time r=0 ]\nP=? [ F&lt;time s=0 ]\nP=? [ F&lt;time (MAX-r-s)=0 ]\n\nRock, the species with the lowest invasion rate, is the most likely to survive. This result is due to the finiteness of the populations, which prevents the system to remain at the fixed point.\nWe can also plot the probability of reaching any absorbing state within the first \\(6\\) time units, i.e.:\nconst int time;\nP=? [F&lt;time (r=0 | r=MAX | s=0) & (s=0 | s=MAX | (MAX-r-s)=0) & ((MAX-r-s)=0 | (MAX-r-s)=MAX | r=0)]\n\nAfter only 5 time steps, the system reaches an absorbing state with certainty.\nBy binning the number of individuals in disjoint intervals (\\(x &lt;= \\text{number of individuals} &lt; x+10\\)), we can plot the probabilities for each species being in a certain interval at time \\(t=1\\), i.e.:\nconst int x;\nP=? [ F=1 r&gt;=x & r&lt;x+10 ]\nP=? [ F=1 s&gt;=x & s&lt;x+10 ]\nP=? [ F=1 (MAX-r-s)&gt;=x & (MAX-r-s)&lt;x+10 ]\n\nAfter a time step, the probability mass of species s and p is concentrated at lower values, while species r has a more uniform distribution.\nPRISM can also be used to conduct stochastic simulations. For example, here is a simulation of the system where, similar to the simulation performed with StochPy, species r is the only one to survive.\n\n\n\n5. Petri net analysis\nA graphical representation of a system of chemical reaction can also be given in terms of Petri nets. Several variants of Petri nets exist, here we consider stochastic Petri nets, a variant that allows the modeling of stochastic systems.\nFor the rock-scissors-paper model, analyzing the net through property verification is relatively straightforward and doesn’t provide substantial insights. However, we will carry out this verification as a tutorial to illustrate the step-by-step approach to modeling and analyzing more complex biochemical networks.\nThe Petri net representing the system was created using the Snoopy tool, saved as ./long_range_models/rsp.spn, and subsequently imported into the Charlie tool for analysis.\nLet’s introduce some definitions, necessary for the analysis of the Petri net.\nA Stochastic Petri net consists of places, transitions with corresponding kinetic functions, arcs and tokens. Places represent the species, transitions represent the reactions, arcs represent the flow of species between reactions and tokens represent the number of molecules of each species. The distribution of the tokens in the places is formalized by the notion of marking.\nMore formally, a stochastic Petri net is a quintuple \\(N = (P, T, f, \\nu, m_0)\\), where\n\n\\(P\\) and \\(T\\) are finite, non empty, and disjoint sets. \\(P\\) is the set of places (in the figures represented by circles). \\(T\\) is the set of transitions (in the figures represented by rectangles);\n\\(f : ((P \\times T)\\cup (T \\times P)) \\rightarrow \\mathbb{N}_0\\) defines the set of directed arcs, weighted by nonnegative integer values;\n\\(\\nu:T \\rightarrow \\Psi\\), with \\(\\Psi=M\\rightarrow R\\geq 0\\), is a function that assigns to each transition a function corresponding to the computation of a kinetic formula to every possible marking \\(m \\in M\\);\n\\(m_0 \\in M: P \\rightarrow \\mathbb{N}_0\\) gives the initial marking.\n\nThe stochastic Petri net for the rock-paper-scissor system is shown below, where we set the initial marking \\(P=20, R=50, S=30\\) and made the kinetic functions correspond to the law of mass action with constants equal to the invasion rates \\(P_r=0.2\\), \\(P_s=0.5\\) and \\(P_p=0.3\\):\n\nThe preset of a node \\(x\\in P \\cup T\\) is defined as \\(•x:=\\{y\\in P\\cup T |f(y,x) \\neq 0\\}\\), and its post set as \\(x• :=\\{y\\in P \\cup T| f(x,y) \\neq 0\\}\\). Altogether we get four types of sets: - \\(•t\\), the preplaces of a transition \\(t\\), consisting of the reaction’s precursors - \\(t•\\), the postplaces of a transition \\(t\\), consisting of the reaction’s products - \\(•p\\), the pretransitions of a place \\(p\\), consisting of all reactions producing this species - \\(p•\\), the posttransitions of a place \\(p\\), consisting of all reactions consuming this species\nGiven a set of places \\(S=p_1, p_2, \\ldots\\), the pre-transition of a set of places \\(S\\) is defined as \\(•S=•p_1 \\cup •p_2 \\cup \\ldots\\), while the post-transition of a set of places \\(S\\) is defined as \\(S•=p_1• \\cup p_2• \\cup \\ldots\\).\nIn this particular net, the pretransition and posttransition of the sites are as follows: - \\(•P=\\{Pp\\}\\) - \\(•R=\\{Pr\\}\\) - \\(•S=\\{Ps\\}\\) - \\(P•=\\{Pp,Ps\\}\\) - \\(R•=\\{Pr,Pp\\}\\) - \\(S•=\\{Ps,Pr\\}\\)\nThe incidence matrix of \\(\\mathcal{N}\\) is a matrix \\(C:P\\times T \\rightarrow \\mathbb{Z}\\), indexed by \\(P\\) and \\(T\\), such that \\(C(p,t)=f(t,p)−f(p,t)\\).\nLoading the file containing the incidence matrix produced by Charlie:\n\n\nCode\n!cat ../results/petri_net_incidence_matrix.txtm\n\n\nplaceNames = {P R S };\ntransitionNames = {Pp Pr Ps };\nC=[\n1 0 -1 ;\n-1 1 0 ;\n0 -1 1 ;\n];\n\n\nWe can easily verify that it is obtained by \\[C = \\begin{bmatrix}\n2 & 0 & 0 \\\\\n0 & 2 & 0 \\\\\n0 & 0 & 2\n\\end{bmatrix}\n-\n\\begin{bmatrix}\n1 & 0 & 1 \\\\\n1 & 1 & 0 \\\\\n0 & 1 & 1\n\\end{bmatrix}\\]\nand we can compute its rank (which is necessary to determine if certain properties of the net hold, as discussed later) as follows:\n\n\nCode\nC = Matrix([[1, 0, -1], [-1, 1, 0], [0, -1, 1]])\nrank = C.rank()\nrank\n\n\n2\n\n\nA place vector (transition vector) is a vector \\(x : P \\rightarrow \\mathbb{Z}\\), indexed by \\(P\\) (\\(y : T \\rightarrow \\mathbb{Z}\\), indexed by \\(T\\)).\nA place vector (transition vector) is called a P-invariant (T-invariant) if it is a nontrivial nonnegative integer solution of the linear equation system \\(x \\cdot C = 0\\) (\\(C \\cdot y = 0\\)).\nIf \\(p\\) is a P-invariant, then the weighted sum of tokens across the places (using the weights specified by the p-invariant) is preserved under the firing of transitions. If \\(t\\) is a T-invariant, then if you fire the transitions according to the vector \\(t\\) (where the number of times each transition is fired is given by the corresponding entry in \\(t\\)), the net’s marking will remain unchanged.\nComputing P-invariants:\n\n\nCode\nx1, x2, x3 = symbols('x1 x2 x3')\nx = Matrix([x1, x2, x3])\nequation = Eq(x.T * C, Matrix([[0, 0, 0]]))\nsolution = solve(equation, (x1, x2, x3), dict=True)\nsolution\n\n\n[{x1: x3, x2: x3}]\n\n\nAny vector of the form \\([x,x,x]\\) is a place invariant. In fact it is trivial that the sum of the number of tokens in the places is constant (equal to \\(100\\)).\nChecking the file containing the P-invariants computed by Charlie:\n\n\nCode\n!cat ../results/rsp_P.inv\n\n\nminimal semipositive place invariants=\n1   |   0.P     :1,\n    |   1.R     :1,\n    |   2.S     :1\n\n\nThe vector \\([1, 1, 1]\\) is a P-invariant for any multiplicative constants.\nComputing T-invariants:\n\n\nCode\ny1, y2, y3 = symbols('y1 y2 y3')\ny = Matrix([y1, y2, y3])\nequation = Eq(C * y, Matrix([[0, 0, 0]]).T)\nsolution = solve(equation, (y1, y2, y3), dict=True)\nsolution\n\n\n[{y1: y3, y2: y3}]\n\n\nAny vector of the form \\([y,y,y]\\) is a transition invariant. In fact it is trivial that applying the three transitions an equal number of times will not change the marking of the net.\nChecking the file containing the T-invariants computed by Charlie:\n\n\nCode\n!cat ../results/rsp_T.inv\n\n\nminimal semipositive transition invariants=\n1   |   0.Pp        :1,\n    |   1.Pr        :1,\n    |   2.Ps        :1\n\n\nThe vector \\([1, 1, 1]\\) is a P-invariant for any multiplicative constants.\nAll markings, which can be reached from a given marking \\(m\\) by any firing sequence of arbitrary length, constitute the set of reachable markings \\([m⟩\\). For this specific net, the set of reachable markings is straightforward to compute: it consists of all possible triples of elements less than \\(100\\) that sum to \\(100\\).\nA transition t is dead in the marking m if it is not enabled in any marking \\(m^{\\prime}\\) reachable from m: \\(\\nexists m^{\\prime} \\in [m⟩ : m^{\\prime}[t⟩\\). A transition t is live if it is not dead in any marking reachable from \\(m_0\\).\nA marking \\(m\\) is dead if there is no transition which is enabled in \\(m\\).\nA nonempty set of places \\(D \\subseteq P\\) is called siphon if \\(•D \\subseteq D•\\) (the set of pretransitions is contained in the set of posttransitions), i.e. every transition which fires tokens onto a place in this structural deadlock set, also has a preplace in this set.\nIn this particular net, we have: - \\(•\\{P\\} = \\{Pp\\} \\subseteq \\{P\\}•=\\{Pp, Ps\\} \\implies \\{P\\}\\) is a siphon - \\(•\\{R\\} = \\{Pr\\} \\subseteq \\{R\\}•=\\{Pr, Pp\\} \\implies \\{R\\}\\) is a siphon - \\(•\\{S\\} = \\{Ps\\} \\subseteq \\{S\\}•=\\{Ps, Pr\\} \\implies \\{S\\}\\) is a siphon - \\(•\\{R,S\\}=\\{Pr, Ps\\} \\subseteq \\{R,S\\}•=\\{Pr, Pp, Ps\\} \\implies \\{R,S\\}\\) is a siphon - \\(•\\{P, R\\} = \\{Pp, Pr\\} \\subseteq \\{P, R\\}• = \\{Pp, Ps, Pr\\} \\implies \\{P, R\\}\\) is a siphon - \\(•\\{P, S\\} = \\{Pp, Ps\\} \\subseteq \\{P, S\\}• = \\{Pp, Ps, Pr\\} \\implies \\{P, S\\}\\) is a siphon - \\(•\\{P, R, S\\} = \\{Pp, Pr, Ps\\} = \\{P, R, S\\}• = \\{Pp, Pr, Ps\\} \\implies \\{P, R, S\\}\\) is a siphon\nOnce a siphon becomes empty (i.e., contains no tokens), it cannot be refilled with tokens by the firing of any transitions (i.e. such part of the system becomes permanently disabled). This means that once a species (or a couple of species) goes extinct, it cannot be reintroduced in the system.\nA siphon is minimal if it does not properly contain a non-empty siphon.\nIn this particular net, \\(\\{P\\}, \\{R\\}, \\{S\\}\\) are minimal siphons.\nChecking the file containing the minimal siphons computed by Charlie:\n\n\nCode\n!cat ../results/rsp_DLS.res\n\n\n minimal proper siphon ( place )= \n\n1   |0.P    :1\n2   |1.R    :1\n3   |2.S    :1\n@\n\n1| siphon_1| minimal siphon_1\n2| siphon_2| minimal siphon_2\n3| siphon_3| minimal siphon_3\n\n\nA set of places \\(Q \\subseteq P\\) is called trap if \\(Q• \\subseteq •Q\\) (the set of posttransitions is contained in the set of pretransitions), i.e. every transition which subtracts tokens from a place of the trap set, also has a postplace in this set.\nIn this particular net, we have: - \\(\\{P\\}•=\\{Pp, Ps\\} \\nsubseteq •\\{P\\} = \\{Pp\\}\\implies \\{P\\}\\) is not a trap - \\(\\{R\\}•=\\{Pr, Pp\\} \\nsubseteq •\\{R\\} = \\{Pr\\} \\implies \\{R\\}\\) is not a trap - \\(\\{S\\}•=\\{Ps, Pr\\} \\nsubseteq •\\{S\\} = \\{Ps\\} \\implies \\{S\\}\\) is not a trap - \\(\\{R,S\\}•=\\{Pr, Pp, Ps\\} \\nsubseteq •\\{R,S\\}=\\{Pr, Ps\\} \\implies \\{R,S\\}\\) is not a trap - \\(\\{P, R\\}• = \\{Pp, Ps, Pr\\} \\nsubseteq •\\{P, R\\} = \\{Pp, Pr\\} \\implies \\{P, R\\}\\) is not a trap - \\(\\{P, S\\}• = \\{Pp, Ps, Pr\\} \\nsubseteq •\\{P, S\\} = \\{Pp, Ps\\} \\implies \\{P, S\\}\\) is not a trap - \\(\\{P, R, S\\}• = \\{Pp, Pr, Ps\\} = •\\{P, R, S\\} = \\{Pp, Pr, Ps\\} \\implies \\{P, R, S\\}\\) is a trap\nA trap is minimal if it does not properly contain a non-empty trap.\nIn this particular net, \\(\\{P, R, S\\}\\) is a minimal trap.\nChecking the file containing the minimal traps computed by Charlie:\n\n\nCode\n!cat ../results/rsp_TPS.res\n\n\n minimal traps ( place )= \n\n1   |0.P    :1,\n    |1.R    :1,\n    |2.S    :1\n\n\nThe “Net Properties” dialog in Charlie provides an overview of the key properties of the net. For this particular net, they are shown below:\n\nThe properties are described in the following Table (sourced from [3]).\n\n\n\n\n\n\n\n\n\nAbbreviation\nName\nDescription\nStatus\n\n\n\n\nPUR\npure\n\\(\\forall x, y \\in P \\cup T : f (x, y) \\neq 0 \\implies f (y, x) = 0\\), i.e. there are no two nodes, connected in both directions. This precludes read arcs. Then the net structure is fully represented by the incidence matrix, which is used for the calculation of the P- and T-invariants.\n❌\n\n\nORD\nordinary\n\\(\\forall x, y \\in P \\cup T : f (x, y) \\neq 0 \\implies f (x, y) = 1\\), i.e. all arc weights are equal to 1. This includes homogeneity. A non-ordinary Petri net cannot be live and 1-bounded at the same time.\n❌\n\n\nHOM\nhomogeneous\n\\(\\forall p \\in P :t,t^{\\prime} \\in p• \\implies f(p,t)=f(p,t^{\\prime})\\), i.e. all outgoing arcs of a given place have the same multiplicity.\n✅\n\n\nNBM\nnon blocking multiplicity\nA net has non-blocking multiplicity if \\(\\forall p \\in P :•p \\neq \\emptyset \\land min\\{f(t,p)\\vert \\forall t \\in •p\\}\\geq max\\{f(p,t)\\vert \\forall t \\in p•\\}\\), i.e. an input place causes blocking multiplicity. Otherwise, it must hold for each place: the minimum of the multiplicities of the incoming arcs is not less than the maximum of the multiplicities of the outgoing arcs.\n✅\n\n\nCSV\nconservative\nA Petri net is conservative if \\(\\forall t \\in T : \\sum_{p \\in •t} f(p,t) = \\sum_{p \\in t•} f(t,p)\\) i.e. all transitions add exactly as many tokens to their postplaces as they subtract from their preplaces, or briefly, all transitions fire token-preservingly. A conservative Petri net is structurally bounded.\n✅\n\n\nSCF\nstructurally conflict free\nA Petri net is static (or structurally) conflict free if \\(\\forall t,t^{\\prime} \\in T :t \\neq t^{\\prime} \\implies •t \\cap •t^{\\prime} = \\emptyset\\), i.e. there are no two transitions sharing a preplace. Transitions involved in a static conflict compete for the tokens on shared preplaces. Thus, static conflicts indicate situations where dynamic conflicts, i.e. nondeterministic choices, may occur in the system behaviour. However, it depends on the token situation whether a conflict does actually occur dynamically. There is no nondeterminism in SCF nets.\n❌\n\n\nFT0\nevery transition has a pre-place\n\\(\\forall t: •t \\neq \\emptyset\\)\n✅\n\n\nTF0\nevery transition has a post-place\n\\(\\forall t: t• \\neq \\emptyset\\)\n✅\n\n\nFP0\nevery place has a pre-transition\n\\(\\forall p: •p \\neq \\emptyset\\)\n✅\n\n\nPF0\nevery place has a post-transition\n\\(\\forall p: p• \\neq \\emptyset\\)\n✅\n\n\nCON\nconnected\nA Petri net is connected if it holds for every two nodes \\(a\\) and \\(b\\) that there is an undirected path between \\(a\\) and \\(b\\). Disconnected parts of a Petri net cannot influence each other, so they can usually be analysed separately.\n✅\n\n\nSC\nstrongly connected\nA Petri net is strongly connected if it holds for every two nodes \\(a\\) and \\(b\\) that there is a directed path from \\(a\\) to \\(b\\). Strong connectedness involves connectedness and the absence of boundary nodes. It is a necessary condition for a Petri net to be live and bounded at the same time.\n✅\n\n\nNC\nnetclass\nThe net structure class: 1) A Petri net is called State Machine (SM) if \\(\\forall t\\in T :\\vert •t \\vert =\\vert t•\\vert \\leq 1\\), i.e. there are neither forward branching nor backward branching transitions. 2) A Petri net is called Synchronisation Graph (SG) if \\(\\forall p\\in P :\\vert •p\\vert =\\vert p•\\vert \\leq 1\\), i.e. there are neither forward branching nor backward branching places. 3) A Petri net is called Extended Free Choice (EFC) if \\(\\forall p,q\\in P:p• ∩q• =\\emptyset \\lor p• =q•\\), i.e. transitions in conflict have identical sets of preplaces. 4) A Petri net is called Extended Simple (ES) if \\(\\forall p,q\\in P:p• \\cap q• =\\emptyset \\lor p• \\subseteq q• \\lor q• \\subseteq p•\\), i.e. every transition is involved in one conflict at most. 5) If the net does not comply to any of the introduced net structure classes, it is said to be not Extended Simple (nES).\nnES\n\n\nRKTH\nrank theorem\n\\(rank(IM) \\neq \\vert SCCS\\vert - 1 \\implies !RKTH\\), i.e. if the rank of the incidence matrix is not equal to the number of strongly connected components (maximal sets of strongly connected nodes) minus one, then the rank theorem does not hold.\n❌\n\n\nSTP\nsiphon trap property\nThe siphon trap property holds if no siphons are bad. A siphon is called bad if it does not include a trap.\n❌\n\n\nCPI\ncovered by P-invariants\nA net is covered by P-invariants, shortly CPI, if every place belongs to a P-invariant.\n✅\n\n\nCTI\ncovered by T-invariants\nA net is covered by T-invariants, shortly CTI, if every transition belongs to a T-invariant.\n✅\n\n\nSCTI\nstrongly covered by T-invariants\nThe two transitions modelling the two directions of a reversible reaction always make a minimal T-invariant and they are called trivial T-invariants. A net which is covered by nontrivial T-invariants is said to be strongly covered by T-invariants.\n✅\n\n\nSB\nstructurally bounded\nA net is structurally bounded if it is bounded for any initial marking\n✅\n\n\nk-B\nk-bounded\nA place \\(p\\) is k-bounded (bounded for short) if there exists a positive integer number \\(k\\), which represents an upper bound for the number of tokens on this place in all reachable markings of the Petri net: \\(\\exists k \\in \\mathbb{N}_0 :\\forall m\\in [m_0⟩:m(p)\\leq k\\). A Petri net is k-bounded (bounded for short) if all its places are k-bounded.\n100\n\n\nDCF\ndynamically conflict free\nDynamic conflict is a behavioural property which refers to a marking enabling two transitions, but the firing of one transition disables the other one. The occurrence of dynamic conflicts causes alternative (branching) system behaviour, whereby the decision between these alternatives is taken nondeterministically.\n❌\n\n\nDSt\nno dead state(s)\nTrue if the net does not have dead states (markings).\n3\n\n\nDTr\nno dead transition(s)\nIf the net does not have dead transitions at the initial state.\n✅\n\n\nLIV\nlive\nA Petri net is live (strongly live) if each transition is live.\n❌\n\n\nREV\nreversible\nA Petri net is reversible if the initial marking can be reached again from each reachable marking: \\(\\forall m \\in [m_0⟩ : m_0 \\in [m⟩\\)\n❌\n\n\n\nCharlie checks these properties by applying a set of rules, as shown in the log file generated by the tool:\n\n\nCode\n!cat ../results/charlie_log.txt\n\n\n\nstarts analysis with following options:\ncharlie.analyzer.structural.StructuralOptionSet\n\nnumber of places: 3\nnumber of transitions: 3\nnumber of arcs: 9\n\ninput places:\nno input places\noutput places:\nno output places\ninput transitions:\nno input transitions\noutput transitions:\nno output transitions\n\nStructural coupled conflict sets: \n\n1   |0.Pp   :1,\n    |1.Pr   :1,\n    |2.Ps   :1\n \nStructural equal conflict sets: \n\n1   |0.Pp   :1\n2   |1.Pr   :1\n3   |2.Ps   :1\n \ntime:  0 m 0 s\n\n\n\nApplying rule:\nCSV =&gt; k-B\n\n\nApplying rule:\nCSV =&gt; SB\n\n\nApplying rule:\nSC =&gt; CON\n\n\nApplying rule:\nCSV =&gt; CPI\n\n\nApplying rule:\nCPI =&gt; k-B\n\n\nApplying rule:\nSB =&gt; k-B\n\n\nApplying rule:\nCPI =&gt; SB\n\nAnalyzer: Rank of Matrix Analyzer\nstart time: 19/08/24, 15:09\nstarts analysis with following options:\ncharlie.analyzer.invariant.RankIncidenceMatrixOptionSet\nRank of the incidence matrix: 2\ntime: 00:00:00:013\n\n\n\nApplying rule:\nrank(IM) != |SCCS| - 1 =&gt; !RKTH\n\nAnalyzer: Structurally Bounded Analyzer\nstart time: 19/08/24, 15:09\nstarts analysis with following options:\nGUI.app_components.StructurallyBoundedOptionSet\ntime: 00:00:00:013\n\nAnalyzer: InvariantAnalyzer\nstart time: 19/08/24, 15:10\nstarts analysis with following options:\nInvariant Options:\ncompute: P-Invariants\ndelete Trivial Invariants: no\ncheck coverage: yes\ncheck extended coverage: no\nenable MCSC: no\nInvariant Analyzer: computing P-Invariants\nminimal semipositive place invariants: \n1\ntime: 00:00:00:014\n\nAnalyzer: InvariantAnalyzer\nstart time: 19/08/24, 15:10\nstarts analysis with following options:\nInvariant Options:\ncompute: T-Invariants\ndelete Trivial Invariants: no\ncheck coverage: yes\ncheck extended coverage: yes\nenable MCSC: no\nInvariant Analyzer: computing T-Invariants\ncheck coverage:\nnet is covered by T-Invariants\nnet does is support strong Coverage by T Invariants\nminimal semipositive transition invariants:\n1\ntime: 00:00:00:015\n\nAnalyzer: Trap Analyzer\nstart time: 19/08/24, 15:10\nstarts analysis with following options:\nTrapOptions:\ncompute: true\nexport: false\nexportFile:  not set!\nproperSets: false\nTrap Analyzer: \ncomputed minimal traps\n    \nminimal traps:\n1 minimal traps computed in 00:00:00:000\ntime: 00:00:00:008\n\nAnalyzer: Siphon Analyzer\nstart time: 19/08/24, 15:10\nstarts analysis with following options:\nsiphon options\nSiphon Analyzer:\n computing siphons\n\nSTP is not valid\n counter examples:\n    siphon:\n    |0.P    :1\n    is a bad siphon\n1 siphons computed 00:00:00:000\ntime: 00:00:00:000\n\nAnalyzer: RGraph Simple Construction\nstart time: 19/08/24, 15:14\nstarts analysis with following options:\nused construction options:\nfiring rule: single\nboundedness check: yes\nmaximal construction depth: none\nreduction: none\ninitial marking:(P: 20 | R: 50 | S: 30)\nreachability graph analyzer:\ncomputing rechability graph using simple  firing rule\ntransition not live:\n    |0.Pp   :1,\n    |1.Pr   :1,\n    |2.Ps   :1\ntransition dead at m0:\n    empty set\nthe net is not live\nis not persistent\nthe net is not safe\nnumber of dead states: 3\nfilter for dead states: \ndead state 1: P== 100\ndead state 2: R== 100\ndead state 3: S== 100\n-- reachability graph constructed in 00:00:52:162--\nused construction options:\nfiring rule: single\nboundedness check: yes\nmaximal construction depth: none\nreduction: none\ninitial marking:(P: 20 | R: 50 | S: 30)\nstates: 5151\nbound: 100\nedges: 14850\n#scc: 301\n#terminal scc: 3\ntime: 00:00:52:162\n\n\n\nApplying rule:\nDSt =&gt; !LIV\n\n\n\nResults:\nPUR   ORD   HOM   NBM   CSV   SCF   FT0   TF0   FP0   PF0   CON   SC    NC  \n   N     N     Y     Y     Y     N     Y     Y     Y     Y     Y     Y    nES \n RKTH   STP   CPI   CTI  SCTI    SB   k-B   1-B   DCF   DSt   DTr   LIV   REV \n   N     N     Y     Y     Y     Y    100    N     N      3    Y     N     N  \n  SSI   RNK  SCCS  SEQS                                                       \n   Y      2     1     3\n\n\nSince a stochastic Petri net can be translated into a CTMC, Charlie provides the possibility to export the net in the PRISM input language. Let’s check whether the PRISM model produced by Charlie corresponds to the one we manually created:\n\n\nCode\n!cat ../long_range_models/rsp.sm\n\n\n//created by Snoopy 2\n//date: Sun Aug 18 14:58:29 2024\n\nctmc\n\nconst int Max;\nconst int N;\nmodule  rsp\n\nS:  [ 0..Max ]  init 30*N;\nR:  [ 0..Max ]  init 50*N;\nP:  [ 0..Max ]  init 20*N;\n\n\n[Pp]\n(P &gt; 0) & (R &gt; 0)\n -&gt; (0.3) * P * R : \n(P' = P+1) & (R' = R-1);\n\n\n[Pr]\n(R &gt; 0) & (S &gt; 0)\n -&gt; (0.2) * R * S : \n(R' = R+1) & (S' = S-1);\n\n\n[Ps]\n(P &gt; 0) & (S &gt; 0)\n -&gt; (0.5) * S * P : \n(P' = P-1) & (S' = S+1);\n\n\n\n\n\nendmodule\n\n\nAside from the missing constraints on the variables’ maximum values, the model is identical to the one we manually created."
  },
  {
    "objectID": "notebooks/long_range_simulations.html#references",
    "href": "notebooks/long_range_simulations.html#references",
    "title": "Long range dispersal model",
    "section": "6. References",
    "text": "6. References\n\n[1] Frean, Marcus, and Edward R. Abraham. “Rock–scissors–paper and the survival of the weakest.” Proceedings of the Royal Society of London. Series B: Biological Sciences 268.1474 (2001): 1323-1327.\n[2] Weissing, Franz J. “Evolutionary stability and dynamic stability in a class of evolutionary normal form games.” Game equilibrium models I: evolution and game dynamics. Berlin, Heidelberg: Springer Berlin Heidelberg, 1991. 29-97.\n[3] Heiner, Monika, David Gilbert, and Robin Donaldson. “Petri nets for systems and synthetic biology.” International school on formal methods for the design of computer, communication and software systems. Berlin, Heidelberg: Springer Berlin Heidelberg, 2008. 215-264."
  },
  {
    "objectID": "notebooks/repressilator.html",
    "href": "notebooks/repressilator.html",
    "title": "The repressilator",
    "section": "",
    "text": "This notebook explores an oscillatory network of transcriptional regulators known as a repressilator. First, we will outline the protein production model, considering also the impact of repressors. Then, we will introduce the repressilator and simulate its dynamics.\nThis system was originally developed as a proof of concept to demonstrate that artificial biological constructs could reliably mimic the behavior of electrical circuits. Although the repressilator itself did not have a direct practical application, it paved the way for the development of biological circuits with more practical purposes, such as systems that can count events or activate functions after a fixed period. These advancements hold potential for applications in drug delivery, nano-construction, and other fields. Additionally, the study of oscillatory networks like the repressilator is inspired by natural biological systems, such as the circadian clocks in organisms that track and anticipate daily environmental changes. This area of research is significant, as evidenced by the 2017 Nobel Prize awarded to Jeffrey Hall, Michael Rosbash, and Michael Young for their discoveries on how internal clocks and biological rhythms govern human life.\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import odeint"
  },
  {
    "objectID": "notebooks/repressilator.html#modeling-protein-dynamics-and-gene-regulation",
    "href": "notebooks/repressilator.html#modeling-protein-dynamics-and-gene-regulation",
    "title": "The repressilator",
    "section": "Modeling Protein Dynamics and Gene Regulation",
    "text": "Modeling Protein Dynamics and Gene Regulation\nWe assume that proteins are produced at a constant rate \\(\\beta\\), but they are also removed through active degradation and dilution during cell growth and division. This removal is modeled as a first-order process, with a rate constant \\(\\gamma\\). Consequently, the rate of change in protein concentration \\(x\\) over time is described by the following ordinary differential equation,\n\\[\\frac{\\partial x}{\\partial t}=\\text{production}-(\\text{degradation}+\\text{dilution})=\\beta-\\gamma \\cdot x\\]\nThe removal rate is proportional to \\(x\\) because, as the concentration of protein molecules increases, the total rate of removal also increases.\nGenes are not continuously “on” but are regulated by cellular mechanisms that adjust their expression levels based on environmental conditions and the cell’s state. Repressors are crucial in this regulation; these proteins bind to specific DNA sequences near a gene’s promoter, influencing gene expression. When a repressor binds, gene expression decreases, and when it unbinds, expression increases.\nThe binding and unbinding of repressors can be modeled as a reversible chemical reaction:\n\\[P+R\\underset{k-}{\\xrightleftharpoons{k_+}} P_{\\text{bound}}\\]\nwhere \\(P\\) is the unbound promoter, \\(R\\) is the repressor, and \\(P\\) bound is the promoter-repressor complex.\nThe dynamics of this chemical reaction can be modeled using mass action kinetics, where we assume that the reaction rate is proportional to the concentrations of the reactants. Hence, we can represent the “concentration” of target sites in bound or unbound states with continuous variables. Although each DNA site within an individual cell is either bound or unbound and is thus best modeled with discrete variables, averaging over a population of cells allows us to use continuous variables to describe the mean occupancy of the site. Let \\(r\\) be the concentration of repressor, \\(p\\) be the concentration of unbound promoter, \\(p_{\\text{bound}}\\) be the concentration of promoter bound with a repressor, then\n\\[\\frac{\\partial p}{\\partial t}=-k_+\\cdot p \\cdot r + k_-\\cdot p_{\\text{bound}}\\]\nRepressor binding and unbinding to the DNA site occur much faster than changes in protein concentrations. Therefore, on the timescale of protein concentration changes, these binding dynamics quickly reach a steady state, where \\(\\partial{p}/\\partial{t}\\approx 0\\) (despite the ongoing binding and unbinding, their overall effect remains constant over time). Consequently, the binding dynamics can be approximated by:\n\\[-k_+\\cdot p \\cdot r + k_-\\cdot p_{\\text{bound}}=0\\]\nIf \\(p_{\\text{tot}}\\) is the total concentration of promoters, bound or not, then \\(p_{\\text{tot}}=p+p_{\\text{bound}}\\), and we have\n\\[-k_+\\cdot p \\cdot r + k_-\\cdot (p_{\\text{tot}}-p)=0\\]\nwhich can be rearranged to give the fraction of promoters that are free to allow transcription,\n\\[\\frac{p}{p_{\\text{tot}}}=\\frac{k_-}{k_-+k_+\\cdot r}=\\frac{1}{1+\\frac{k_+}{k_-}\\cdot r}=\\frac{1}{1+\\frac{r}{K_d}}\\]\nwhere we have defined the dissociation constant for repressor-target binding\n\\[K_d=\\frac{k_-}{k_+}\\]\nThe rate of protein production should be proportional to the probability of the promoter being unbound, therefore\n\\[\\beta(r)=\\beta_0\\cdot \\frac{p}{p_{\\text{tot}}}=\\frac{\\beta_0}{1+\\frac{r}{K_d}}\\]\nAlthough this repressive function effectively captures the behavior of a basic transcriptional regulation model, real-world gene regulation and protein-protein interactions often display more switch-like or ultrasensitive characteristics. Ultrasensitivity can originate from various mechanisms, one key source being cooperativity in molecular interactions. For instance, when a protein binds to one DNA site, it can enhance the binding affinity of a second protein at a nearby site. In such cases, an increasing concentration of one component may initially have little effect but eventually lead to a dramatic response.\nHill function offers a phenomenological method to analyze systems with ultrasensitive responses. A repressive Hill function is given by\n\\[f_{\\text{rep}}(x)=\\frac{1}{1+(\\frac{x}{k})^n}\\]\nhere, the Hill coefficient, \\(n\\), describes the degree of ultrasensitivity. For \\(n=1\\), this reduces to the simple repressive function discussed earlier. When \\(n&gt;1\\), the response becomes increasingly sharper and more ultrasensitive, approaching a perfect step function as \\(n\\) approaches infinity, as shown in the plot below.\n\nn_vals = [1, 2, 10, 25, np.inf]\nx = np.concatenate((np.linspace(0, 1, 200), np.linspace(1, 4, 200)))\nf_rep = []\nfor n in n_vals:\n    if n == np.inf:\n        f_rep.append(np.concatenate((np.ones(200), np.zeros(200))))\n    else:\n        f_rep.append(1 / (1 + x ** n))\ndf = pd.DataFrame(np.array(f_rep).T, columns=[f\"n={n}\" for n in n_vals])\ndf['x'] = x\ndf.plot(\n    x='x', y=[f\"n={n}\" for n in n_vals],\n    ylabel=\"repressing Hill function\", xlabel=\"$x/k$\",\n    colormap=\"Reds\", linewidth=3\n)\nplt.grid()\n\n\n\n\nThe production rate of gene products under a repressor with ultrasensitivity, modeled by the Hill function, is then\n\\[\\beta(r)=\\beta_0\\cdot f_{\\text{rep}(r)}=\\beta_0 \\frac{1}{1+(\\frac{r}{k})^n}\\]\nTo simplify notation, we will omit the subscript \\(0\\) from \\(\\beta\\) in the following discussions."
  },
  {
    "objectID": "notebooks/repressilator.html#description-and-analysis-of-the-repressilator-dynamics",
    "href": "notebooks/repressilator.html#description-and-analysis-of-the-repressilator-dynamics",
    "title": "The repressilator",
    "section": "Description and Analysis of the Repressilator Dynamics",
    "text": "Description and Analysis of the Repressilator Dynamics\nThe repressilator is a genetic regulatory network consisting of a feedback loop with at least three genes, each expressing a protein that represses the next gene in the loop. The dynamic behavior of the repressilator mirrors the competitive interactions of the rock-paper-scissors game, as each component cyclically inhibits the next.\nThe system of differential equations describing the repressilator is given by\n\\[\\begin{cases}\n\\frac{\\partial x_1}{\\partial t}=\\frac{\\beta}{1+(\\frac{x_3}{k})^n}-\\gamma x_1\\\\\n\\frac{\\partial x_2}{\\partial t}=\\frac{\\beta}{1+(\\frac{x_1}{k})^n}-\\gamma x_2\\\\\n\\frac{\\partial x_3}{\\partial t}=\\frac{\\beta}{1+(\\frac{x_2}{k})^n}-\\gamma x_3\\\\\n\\end{cases}\\]\nor in a more compact form \\[\\frac{\\partial x_i}{\\partial t}=\\frac{\\beta}{1+(\\frac{x_j}{k})^n}-\\gamma x_i\\] with \\((i,j)\\) pairs \\((1,3),(2,1),(3,2)\\).\nFor simplicity we assumed perfect symmetry among the species, with each one having identical biochemical properties (this will not be true in the real system).\nTo simplify the equations, we introduce a dimensionless time variable \\(\\tau\\) by rescaling the original time \\(t\\) using \\(\\gamma\\). The new dimensionless time variable \\(\\tau\\) is defined as: \\[\\tau=\\gamma t\\] This means that \\(\\tau\\) is a measure of time in units of \\(\\gamma^{-1}\\).\nThe original time derivative \\(\\frac{\\partial}{\\partial t}\\) can be expressed in terms of \\(\\tau\\) as: \\[\\frac{\\partial}{\\partial t}=\\frac{\\partial \\tau}{\\partial t}\\frac{\\partial}{\\partial \\tau}=\\gamma \\frac{\\partial}{\\partial \\tau}\\] since \\(\\frac{\\partial \\tau}{\\partial t}=\\gamma\\).\nWe now define dimensionless concentrations \\(x_i'\\) as: \\[x_i'=\\frac{x_i}{k}\\] thus \\[x_i=k x_i'\\]\nSubstituting the above definitions into the original equations, we get:\n\\[\\frac{\\partial x_i}{\\partial t}=k \\gamma \\frac{\\partial x_i'}{\\partial \\tau}\\] And since \\[\\frac{\\partial x_i}{\\partial t}= \\frac{\\beta}{1+(x_j')^n}-\\gamma k x_i'\\] we have that \\[\\frac{\\partial x_i'}{\\partial \\tau}=\\frac{\\frac{\\beta}{k\\gamma}}{1+(x_j')^n}- x_i'=\\frac{\\beta'}{1+(x_j')^n}- x_i'\\] where we set \\(\\beta'=\\frac{\\beta}{k \\gamma}\\)\nTo simplify the notation in the following we will use \\(x_i\\) instead of \\(x_i'\\), \\(\\tau\\) instead of \\(t\\) and \\(\\beta\\) instead of \\(\\beta'\\).\nThe system’s dynamics might result in sustained oscillation, where repressor proteins alternate in concentration: if repressor 1 is high, it leads to low levels of repressor 2, which allows repressor 3 to increase and suppress repressor 1, continuing the cycle. However, the system might also stabilize at a steady state, where all three repressors reach intermediate levels, maintaining a balance without oscillations.\nTo design clock circuits, it is essential to ensure that the system exhibits periodic oscillations that persist over time without damping out and can recover from temporary perturbations caused by environmental fluctuations or internal noise.\nThe system’s actual behavior is influenced by its parameters, specifically the Hill coefficient \\(n\\) and the protein production rate \\(\\beta\\). By integrating the dynamical equations, we can track the concentrations of three proteins over time for various values of \\(n\\) and \\(\\beta\\), allowing us to observe how these parameters affect the system’s dynamics\nDefining a function to solve the system of differential equations:\n\ndef repressilator_ODE_solver(x0, t, beta, n):\n    \"\"\"\n    Solve the initial value problem for the repressilator ODE system.\n    \"\"\"\n\n    def repressilator(x, t, beta, n):\n        x1, x2, x3 = x\n\n        d_x1_dt = beta / (1 + x3 ** n) - x1\n        d_x2_dt = beta / (1 + x1 ** n) - x2\n        d_x3_dt = beta / (1 + x2 ** n) - x3\n\n        return [d_x1_dt, d_x2_dt, d_x3_dt]\n\n    y = odeint(repressilator, x0, t, args=(beta, n))\n    return y.T\n\nSolving the system for different values of \\(n\\) and \\(\\beta\\), with initial protein concentrations set to \\(1\\), \\(1\\), and \\(1.1\\) for \\(x_1\\), \\(x_2\\), and \\(x_3\\), respectively (we avoided setting \\(x_1 = x_2 = x_3\\) to prevent the dynamics from collapsing into a single equation, which would obscure differences in the proteins’ behavior over time):\n\nparams = {\n    'betas': [2, 10, 100, 2, 10, 100, 2, 10, 100, 2, 10, 100],\n    'ns': [2, 2, 2, 2.5, 2.5, 2.5, 3, 3, 3, 5, 5, 5]\n}\n\nt = np.linspace(0, 40, 1000)\n\ndf = pd.DataFrame()\nfor beta, n in zip(params['betas'], params['ns']):\n    y = repressilator_ODE_solver(x0=np.array([1, 1, 1.1]), t=t, beta=beta, n=n)\n    df_temp = pd.DataFrame(y.T, columns=[\"$x_1$\", \"$x_2$\", \"$x_3$\"])\n    df_temp['$\\\\beta$'] = beta\n    df_temp['$n$'] = n\n    df_temp['t'] = t\n    df = pd.concat([df, df_temp])\n\nPlotting the results:\n\nfig, axs = plt.subplots(4, 3, figsize=(12, 16))\nfor i, (beta, n) in enumerate(zip(params['betas'], params['ns'])):\n    df_temp = df[(df['$\\\\beta$'] == beta) & (df['$n$'] == n)]\n    df_temp.plot(\n        x='t', y=[\"$x_1$\", \"$x_2$\", \"$x_3$\"],\n        xlabel=\"t\",\n        title=f\"({i+1})\\n$\\\\beta={beta}$, $n={n}$\",\n        ax=axs[int(i/3), i%3]\n    )\n    axs[int(i/3), i%3].grid()\nplt.tight_layout()\n\n\n\n\nThrough linear stability analysis, it can be proven that the fixed point is unstable (the system exhibits sustained oscillations) for \\(n&gt;2\\) and \\(\\beta &gt; \\frac{n}{2}(\\frac{n}{2}-1)^{-\\frac{n+1}{n}}\\).\nWe can display the regions of stability and instability in the \\(n\\)-\\(\\beta\\) plane, marking the parameter values used in the previous simulations:\n\nn = np.linspace(2.01, 5, 200)\nbeta = n / 2 * (n / 2 - 1) ** (-((n + 1)/n))\nplt.figure()\nplt.semilogy(n, beta, linewidth=3, c=\"black\")\nplt.fill_between(n, beta, 3000, color=\"lightgray\", alpha=0.7, label=\"unstable region\\n(limit cycle oscillations)\")\nplt.xlabel(\"$n$\")\nplt.ylabel(\"$\\\\beta$\")\nfor i, (beta, n) in enumerate(zip(params['betas'], params['ns'])):\n    plt.scatter(n, beta, c=\"black\", zorder=10)\n    plt.text(n-0.03, beta, f\"({i+1})\", fontsize=12, ha='right')\nplt.legend(loc='center left', bbox_to_anchor=(1, 0.5))\nplt.grid(True, zorder=0)\n\n\n\n\nThe plot indicates that, from a design perspective, maximizing both \\(\\beta\\) and \\(n\\) is crucial for ensuring sustained oscillations in the system. This requires employing strong promoters and ultrasensitive repression curves to achieve the desired oscillatory behavior.\n\n# perchè nel plot sotto usa i parametri che usa?"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Rock, Scissors, Paper: the survival of the weakest",
    "section": "",
    "text": "This project reproduces the experiments conducted by Frean et al. [1] and Reichenbach et al. [2] to study a system involving three species in a competitive loop: a rock beats (and replicates into) a pair of scissors, scissors beat a sheet of paper and paper beats a rock. The self-referential nature of the competitive loop leads to counterintuitive phenomena, such as the expectation that the least competitive species will dominate in population. The proposed model is explored through various formalisms, and its properties are analyzed within each framework.\n\n\nIn the long range dispersal model individuals are treated as gas molecules, with interactions occurring between any pair.\nThe model is examined under both discrete and continuous time frameworks. For the continuous time approach, the differential equation system defining the model is solved using the scipy.integrate package. Additionally, the model is reframed in terms of chemical reactions for stochastic simulations, which are conducted using the StochPy package. It is further examined as a continuous-time Markov chain with the PRISM stochastic model checker and as a Petri net with the tool Charlie.\nView Model Analysis\n\n\n\nIn the lattice model, individuals are situated on a lattice and interact solely with their neighbors.\nThe model is developed using the Mesa framework.\nView Model Analysis\n\n\nAfter cloning the GitHub repository, install the dependencies by executing the following command:\npip install -r requirements.txt\nTo interactively run the model, execute the following command:\npython ./run_lattice_model.py\nSet the grid’s width and height, choose the model to run (either the one based on [1], [2], or a variant where agents activate simultaneously), and then open your browser to http://127.0.0.1:8521/.”\nThe sliders labeled ’Initial weight of species *’ allow you to set the weights used by the random.choices method from the Python Standard Library for initializing grid patches with individuals. These weights don’t need to sum to \\(1\\).\nThe sliders ‘Swap rate’, ‘Reproduce rate’ and ‘Select rate’ in the model based on [2] have the same meaning as those in the NetLogo Rock-Paper-Scissors model [3].\n\n\n\n\n\n\n\n\n\n\n\n[1] Frean, Marcus, and Edward R. Abraham. “Rock–scissors–paper and the survival of the weakest.” Proceedings of the Royal Society of London. Series B: Biological Sciences 268.1474 (2001): 1323-1327.\n[2] Reichenbach, Tobias, Mauro Mobilia, and Erwin Frey. “Mobility promotes and jeopardizes biodiversity in rock–paper–scissors games.” Nature 448.7157 (2007): 1046-1049.\n[3] Head, B., Grider, R. and Wilensky, U. (2017). NetLogo Rock Paper Scissors model. Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL."
  },
  {
    "objectID": "index.html#long-range-dispersal-model",
    "href": "index.html#long-range-dispersal-model",
    "title": "Rock, Scissors, Paper: the survival of the weakest",
    "section": "",
    "text": "In the long range dispersal model individuals are treated as gas molecules, with interactions occurring between any pair.\nThe model is examined under both discrete and continuous time frameworks. For the continuous time approach, the differential equation system defining the model is solved using the scipy.integrate package. Additionally, the model is reframed in terms of chemical reactions for stochastic simulations, which are conducted using the StochPy package. It is further examined as a continuous-time Markov chain with the PRISM stochastic model checker and as a Petri net with the tool Charlie.\nView Model Analysis"
  },
  {
    "objectID": "index.html#lattice-model",
    "href": "index.html#lattice-model",
    "title": "Rock, Scissors, Paper: the survival of the weakest",
    "section": "",
    "text": "In the lattice model, individuals are situated on a lattice and interact solely with their neighbors.\nThe model is developed using the Mesa framework.\nView Model Analysis\n\n\nAfter cloning the GitHub repository, install the dependencies by executing the following command:\npip install -r requirements.txt\nTo interactively run the model, execute the following command:\npython ./run_lattice_model.py\nSet the grid’s width and height, choose the model to run (either the one based on [1], [2], or a variant where agents activate simultaneously), and then open your browser to http://127.0.0.1:8521/.”\nThe sliders labeled ’Initial weight of species *’ allow you to set the weights used by the random.choices method from the Python Standard Library for initializing grid patches with individuals. These weights don’t need to sum to \\(1\\).\nThe sliders ‘Swap rate’, ‘Reproduce rate’ and ‘Select rate’ in the model based on [2] have the same meaning as those in the NetLogo Rock-Paper-Scissors model [3]."
  },
  {
    "objectID": "index.html#references",
    "href": "index.html#references",
    "title": "Rock, Scissors, Paper: the survival of the weakest",
    "section": "",
    "text": "[1] Frean, Marcus, and Edward R. Abraham. “Rock–scissors–paper and the survival of the weakest.” Proceedings of the Royal Society of London. Series B: Biological Sciences 268.1474 (2001): 1323-1327.\n[2] Reichenbach, Tobias, Mauro Mobilia, and Erwin Frey. “Mobility promotes and jeopardizes biodiversity in rock–paper–scissors games.” Nature 448.7157 (2007): 1046-1049.\n[3] Head, B., Grider, R. and Wilensky, U. (2017). NetLogo Rock Paper Scissors model. Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL."
  },
  {
    "objectID": "notebooks/lattice_simulations.html",
    "href": "notebooks/lattice_simulations.html",
    "title": "Lattice model",
    "section": "",
    "text": "This notebook simulates the evolution of the system with local dispersal, featuring three variants of the rock-paper-scissors game. All lattice-based model were developed using the Mesa framework, which provides visualization tools to observe the spatial structures emerging from agent interactions.\nImporting the necessary libraries:\nCode\nimport sys\nimport os\nimport solara\nimport mesa\nimport numpy as np\nimport pandas as pd\nfrom matplotlib.figure import Figure\nimport plotly.express as px\nimport plotly.figure_factory as ff\nimport matplotlib.pyplot as plt\nfrom mesa.experimental import JupyterViz\nsys.path.append(os.path.abspath('..'))\nfrom lattice_models.model_rand_act import RSPRandAct\nfrom lattice_models.model_sim_act import RSPSimAct\nfrom lattice_models.model_mobility import RSPMobility\n%matplotlib inline"
  },
  {
    "objectID": "notebooks/lattice_simulations.html#frean-and-abraham-model",
    "href": "notebooks/lattice_simulations.html#frean-and-abraham-model",
    "title": "Lattice model",
    "section": "1. Frean and Abraham model",
    "text": "1. Frean and Abraham model\nIn this model the \\(N\\) sites are taken to be sites in a periodic, rectangular lattice and each agent is activated once per time-step, in random order. During each activation, an agent competes with a randomly chosen neighboring agent. If the neighboring agent can be defeated, the agent wins the competition with a probability determined by the invasion rate. If the agent wins the competition, the neighboring agent is transformed into an individual of the same species of the winning agent. For more details, see the original paper [1].\n\n1.1. Implementation details\nThe model is defined by the class RSPRandAct in the file ../lattice_models/model_rand_act.py:\n\n\nCode\n%pycat ../lattice_models/model_rand_act.py\n\n\nimport mesa\nfrom .patch_rand_act import PatchRandAct\nfrom mesa.datacollection import DataCollector\n\nclass RSPRandAct(mesa.Model):\n    \"\"\"\n    A system with three species in a competitive loop: a rock beats a pair of scissors,\n    scissors beat a sheet of paper and paper beats a rock.\n    \"\"\"\n\n    # key: species, value: list of species that the key species can beat\n    # e.g. ROCK (0) beats SCISSOR (1), SCISSOR (1) beats PAPER (2), PAPER (2) beats ROCK (0)\n    rules3 = {0: [1], 1: [2], 2: [0]}\n    rules4 = {0: [1], 1: [2], 2: [3], 3: [0]}\n    rules5 = {0: [1,2], 1: [2,3], 2: [3,4], 3: [4,0], 4: [0,1]}\n\n    def __init__(self,\n                 init0, init1, init2, init3, init4,\n                 invrate0, invrate1, invrate2, invrate3, invrate4,\n                 n_species,\n                 color_map,\n                 increase_rate=False,\n                 width=50, height=50):\n        \"\"\"\n        Create a new playing area of (width, height) patches.\n        \"\"\"\n        super().__init__()\n\n        self.n_species = n_species\n        self.color_map = color_map\n        self.increase_rate = increase_rate\n        if self.n_species == 3:\n            self.init_probabilities = [init0, init1, init2]\n            self.invasion_rates = [invrate0, invrate1, invrate2]\n            self.rules = self.rules3\n        elif self.n_species == 4:\n            self.init_probabilities = [init0, init1, init2, init3]\n            self.invasion_rates = [invrate0, invrate1, invrate2, invrate3]\n            self.rules = self.rules4\n        else: # n_species == 5\n            self.init_probabilities = [init0, init1, init2, init3, init4]\n            self.invasion_rates = [invrate0, invrate1, invrate2, invrate3, invrate4]\n            self.rules = self.rules5\n\n        # set up agent scheduler\n        self.schedule = mesa.time.RandomActivation(self)\n\n        # use a simple grid, where edges wrap around.\n        self.grid = mesa.space.SingleGrid(width, height, torus=True)\n\n        # place a patch at each location, randomly initializing it according to the given initial proportions\n        for _, (x, y) in self.grid.coord_iter():\n            patch_init_state = self.random.choices(range(self.n_species), weights=self.init_probabilities, k=1)[0]\n            patch = PatchRandAct(pos=(x, y), model=self, init_state=patch_init_state)\n            self.grid.place_agent(patch, (x, y))\n            self.schedule.add(patch)\n\n        self.running = True\n        \n        # collect data\n        model_reporter = {}\n        for i in range(self.n_species):\n            model_reporter[i] = lambda model, species=i: model.count_patches(species)\n        if self.increase_rate:\n           model_reporter['increased_rate'] = lambda model: model.invasion_rates[0] # TODO: lambda model: model.compute_average_invrate0()=\n        self.datacollector = DataCollector(\n            model_reporter\n        )\n        self.datacollector.collect(self)\n\n    def count_patches(self, species):\n        \"\"\"\n        Helper method to count the number of patches in the given state.\n        \"\"\"\n        return sum([1 for patch in self.schedule.agents if patch.state == species])\n    \n    def compute_average_invrate0(self): # TODO: delete?\n        rates = [patch.invasion_rate for patch in self.schedule.agents if patch.state == 0]\n        return sum(rates) / len(rates)\n\n    def step(self):\n        \"\"\"\n        Have the scheduler advance each patch by one step.\n        \"\"\"\n        self.schedule.step()\n        self.datacollector.collect(self)\n\n        n_existint_species = sum([1 for i in range(self.n_species) if self.count_patches(i) == 0])\n        if n_existint_species == self.n_species-1:\n            self.running = False\n\n\n\nThe model can be simulated with \\(3\\), \\(4\\), or \\(5\\) species. When there are \\(4\\) species, species \\(&lt;1,3&gt;\\) and \\(&lt;2,4&gt;\\) do not compete with each other.\nEach agent is activated once per step, in random order, with the order reshuffled each step, through the mesa.time.RandomActivation scheduler.\nAgents are situated on a rectangular, periodic grid (i.e. torus), where each cell contains exactly at most one agent. Such a grid is created by the mesa.space.SingleGrid class.\nThe grid is randomly initialized by placing agents in each cell according to the initial proportions of the species (the parameters init* are used as weights in the random.choices function).\n\nThe behavior of each agent (grid patch) is defined by the class PatchRandAct in the file ../lattice_models/patch_rand_act.py:\n\n\nCode\n%pycat ../lattice_models/patch_rand_act.py\n\n\nimport mesa\n\nclass PatchRandAct(mesa.Agent):\n    \"\"\"Represents a single patch in the simulation.\"\"\"\n\n    def __init__(self, pos, model, init_state):\n        \"\"\"\n        Create a patch, in the given state, at the given x, y position.\n        \"\"\"\n        super().__init__(pos, model)\n        self.rules = model.rules\n        self.n_species = model.n_species\n        self.color_map = model.color_map\n        self.x, self.y = pos\n        self.state = init_state\n        self.invasion_rate = self.model.invasion_rates[self.state] # TODO: delete?\n        self._nextState = None\n\n    def step(self):\n        \"\"\"\n        Compute the next state of the patch according to the rules of the game\n        and the invasion rates of the species.\n        \"\"\"\n        # get the neighbors\n        neighbors = self.model.grid.get_neighbors((self.x, self.y), moore=True)\n\n        # select a random neighbor\n        neighbor = self.random.choice(neighbors)\n        \n        # if the neighbor can be defeated\n        if neighbor.state in self.rules[self.state]:\n            # change the neighbor state according to the invasion rate\n            win_rate = self.model.invasion_rates[self.state]\n            new_neigh_state = self.random.choices(\n                [self.state, neighbor.state],\n                weights=[win_rate, 1-win_rate],\n                k=1)[0]\n            neighbor.state = new_neigh_state\n            \n            # increase species 0 invasion rate if needed\n            if (self.model.increase_rate and self.state==0 and \\\n                new_neigh_state==self.state and self.model.schedule.steps&gt;100):\n                rand = self.random.uniform(0, 1e-4)\n                new_rate = self.model.invasion_rates[self.state] + rand\n                if 0 &lt; new_rate &lt; 1:\n                    self.model.invasion_rates[self.state] = new_rate\n\n    def alternative_step(self):\n        \"\"\"\n        Compute the next state of the patch according to the rules of the game\n        and the invasion rates of the species.\n        \"\"\"\n        # get the neighbors\n        neighbors = self.model.grid.get_neighbors((self.x, self.y), moore=True)\n\n        # select a random neighbor\n        neighbor = self.random.choice(neighbors)\n        \n        # if the neighbor can be defeated\n        if neighbor.state in self.rules[self.state]:\n            # change the neighbor state according to the invasion rate\n            win_rate = self.invasion_rate\n            new_neigh_state = self.random.choices(\n                [self.state, neighbor.state],\n                weights=[win_rate, 1-win_rate],\n                k=1)[0]\n            if new_neigh_state != neighbor.state:\n                if self.state==0:\n                    neighbor.invasion_rate = self.invasion_rate\n                else: \n                    neighbor.invasion_rate = self.model.invasion_rates[neighbor.state]\n            neighbor.state = new_neigh_state\n            \n            # increase species 0 individuals invasion rate if needed\n            if (self.model.increase_rate and self.state==0 and \\\n                new_neigh_state==self.state and self.model.schedule.steps&gt;100):\n                rand = self.random.uniform(-1e-2, 1e-2)\n                new_rate = self.invasion_rate + rand\n                if 0 &lt; new_rate &lt; 1:\n                    self.invasion_rate = new_rate\n\n\n\nEach patch has a Moore neighborhood, i.e. the eight cells surrounding it.\nAt each step, a neighbor is randomly chosen and the agent in the patch interacts with it. According on the invasion rates, the neighboring agent can be overtaken and transformed into the same species as the agent in the patch.\nIf the parameter increase_rate is set to True, after \\(100\\) steps the invasion rate of species \\(0\\) is increased whenever it replicates onto a new site. The increment is a random number uniformly distributed between \\(0\\) and \\(10^{-4}\\) and the new invasion rate is accepted if it is in the range \\(0&lt;P_0&lt;1\\)). This is done to replicate the experiment of Figure 3 in [1].\n\n\n\n1.2. Simulations\nDefining functions to run simulations and visualize the evolution of the system:\n\n\nCode\ndef run_model(model_class, params, steps):\n    '''\n    This function runs the model, given the model class,\n    the parameters and the number of steps.\n\n    Parameters\n    ----------\n    model_class : class\n        The model class to be run.\n    params : dict\n        The parameters of the model.\n    steps : int\n        The number of steps to run the model.\n    '''\n    model = model_class(**params)\n    for i in range(steps):\n        model.step()\n    return model\n\ndef agent_portrayal(cell):\n    '''\n    This function defines the appearance of the agents in the visualization.\n\n    Parameters\n    ----------\n    cell : object\n        The agent to be visualized.\n    '''\n    return {\"color\": cell.color_map[cell.state], \"marker\": \"s\", \"size\": 1}\n\ndef draw_grid(grid, agent_portrayal, title=None, ax=None):\n    '''\n    This function draws the lattice grid.\n\n    Parameters\n    ----------\n    grid : object\n        The grid to be visualized.\n    agent_portrayal : function\n        The function that defines the appearance of the agents.\n    title : str\n        The title of the plot.\n    ax : object\n        The matplotlib axis to draw the plot.\n    '''\n    def portray(g):\n        x = []\n        y = []\n        s = []  # size\n        c = []  # color\n        for i in range(g.width):\n            for j in range(g.height):\n                content = g._grid[i][j]\n                if not content:\n                    continue\n                if not hasattr(content, \"__iter__\"):\n                    # Is a single grid\n                    content = [content]\n                for agent in content:\n                    data = agent_portrayal(agent)\n                    x.append(i)\n                    y.append(j)\n                    if \"size\" in data:\n                        s.append(data[\"size\"])\n                    if \"color\" in data:\n                        c.append(data[\"color\"])\n        out = {\"x\": x, \"y\": y}\n        # This is the default value for the marker size, which auto-scales\n        # according to the grid area.\n        out[\"s\"] = (180 / max(g.width, g.height)) ** 2\n        if len(s) &gt; 0:\n            out[\"s\"] = s\n        if len(c) &gt; 0:\n            out[\"c\"] = c\n        return out\n\n    if ax is None:\n        space_fig = Figure()\n        space_ax = space_fig.subplots()\n    else:\n        space_ax = ax\n    space_ax.set_xlim(-1, grid.width)\n    space_ax.set_ylim(-1, grid.height)\n    space_ax.scatter(**portray(grid))\n    space_ax.set_title(title)\n    space_ax.axis('off')\n    if ax is None:\n        return space_fig\n\ndef line_plot(model, title=None, ax=None):\n    '''\n    This function plots the fraction of individuals of each type over time.\n\n    Parameters\n    ----------\n    model : object\n        The model to be visualized.\n    title : str\n        The title of the plot.\n    ax : object\n        The matplotlib axis to draw the plot.\n    '''\n    all_species = []\n    patches_types = model.n_species\n\n    if hasattr(model, 'expected_swap'):\n        all_species.append('empty')\n        patches_types += 1\n\n    all_species.extend(['$n_r$', '$n_s$', '$n_p$', '$n_u$', '$n_v$'])\n\n    if ax is None:\n        fig = Figure()\n        axs = fig.subplots()\n    else:\n        axs = ax\n    model_data = model.datacollector.get_model_vars_dataframe()\n    \n    tot_individuals = 0\n    for i in range(patches_types):\n        tot_individuals += model_data[i]\n    for i in range(patches_types):\n        model_data[i] = model_data[i] / tot_individuals\n    \n    model_data[[i for i in range(patches_types)]].plot(\n        ax=axs,\n        style='-o',\n        color=[model.color_map[i] for i in range(patches_types)]\n    )\n    axs.legend([all_species[i] for i in range(patches_types)])\n    axs.set_xlabel('Time Step')\n    axs.set_ylabel('Fraction of Individuals')\n    axs.set_title(title)\n    \n    if ax is None:\n        solara.FigureMatplotlib(fig)\n        return fig\n\ndef plot_rate_species0(model, title=None):\n    '''\n    This function plots the invasion rate of species 0 over time,\n    alongside the fraction of individuals of that species.\n\n    Parameters\n    ----------\n    model : object\n        The model to be visualized.\n    title : str\n        The title of the plot.\n    '''\n    fig = Figure()\n    ax = fig.subplots()\n    model_data = model.datacollector.get_model_vars_dataframe()\n    tot_individuals = model_data[0] + model_data[1] + model_data[2]\n    model_data[0] = model_data[0] / tot_individuals\n    model_data[[0, 'increased_rate']].plot(ax=ax, style='-o', color=['tab:red', 'black'])\n    ax.legend(['$n_r$', 'average $P_r$'])\n    ax.set_xlabel('Time Step')\n    ax.set_title(title)\n    solara.FigureMatplotlib(fig)\n    return fig\n\ndef ternary_plot_species_evolution(df, title=None, show_markers=True):\n    '''\n    Plot the evolution of species proportions over time in a ternary plot.\n    \n    Parameters\n    ----------\n    df : pd.DataFrame\n        A DataFrame containing the species proportions over time.\n    title : str\n        The title of the plot.\n    show_markers : bool\n        Whether to show markers in the plot.\n    '''\n    fig = px.scatter_ternary(\n        df,\n        a=df.columns[2],\n        b=df.columns[0],\n        c=df.columns[1],\n        color=df.index,\n        color_continuous_scale='blues',\n        size_max=10,\n        title=title\n    )\n    fig.update_layout(\n        width=750,\n    )\n    if show_markers:\n        fig.update_traces(mode='lines+markers', line=dict(color='black', width=1),\n            marker=dict(symbol='circle', line=dict(width=1, color='black')))\n    else:\n        fig.update_traces(mode='lines', line=dict(color='black', width=1))\n    fig.update_layout(coloraxis_colorbar=dict(title='Time'))\n    fig.show('png')\n\n\nLet’s define the parameters to perform a simulation of a system with \\(3\\) species, on a square lattice with \\(N=200\\cdot 200\\) sites and invasion rates \\(P_r=0.2, P_s=0.5, P_p=0.3\\). The grid will be initialized with the sites being randomly assigned to one of the three species (\\(n_r=0.33, n_s=0.33, n_p=0.33\\)). In all the simulations, species \\(R\\) will be represented in red, species \\(S\\) in purple and species \\(P\\) in yellow.\n\n\nCode\ncolor_map = {\n    0: 'red',\n    1: 'purple',\n    2: 'gold',\n}\nmodel_params1 = {\n    \"height\": 200,\n    \"width\": 200,\n    \"n_species\": 3,\n    \"init0\": 0.33,\n    \"init1\": 0.33,\n    \"init2\": 0.33,\n    \"init3\": 0,\n    \"init4\": 0,\n    \"invrate0\": 0.2,\n    \"invrate1\": 0.5,\n    \"invrate2\": 0.3,\n    \"invrate3\": 0,\n    \"invrate4\": 0,\n    \"color_map\": color_map\n}\n\n\nRunning the simulation for \\(300\\) steps:\n\n\nCode\nmodel1 = run_model(model_class=RSPRandAct, params=model_params1, steps=300)\nresults_df = model1.datacollector.get_model_vars_dataframe().rename(columns={0: '$n_r$', 1: '$n_s$', 2: '$n_p$'})\n\n\nDefining a function to build the title for the plots using the model’s parameters:\n\n\nCode\ndef build_title(params, steps=None):\n    '''\n    This function builds the title for the plots using the parameters of the model.\n\n    Parameters\n    ----------\n    params : dict\n        The parameters of the model.\n    steps : int\n        The number of steps the model was run.\n    '''\n    title = rf\"$N={params['height']} \\times {params['width']},\"\n\n    if 'swap_exp' in params:\n        title += f\" empty={params['init0']:.2f}, n_r^0={params['init1']:.2f}, n_s^0={params['init2']:.2f}, n_p^0={params['init3']:.2f}\"\n        if params['init4'] &gt; 0:\n            title += f\", n_u^0={params['init4']:.2f}\"\n        if params['init5'] &gt; 0:\n            title += f\", n_v^0={params['init5']:.2f}\"\n    else:\n        title += f\" n_r^0={params['init0']:.2f}, n_s^0={params['init1']:.2f}, n_p^0={params['init2']:.2f}\"\n        if params['init3'] &gt; 0:\n            title += f\", n_u^0={params['init3']:.2f}\"\n        if params['init4'] &gt; 0:\n            title += f\", n_v^0={params['init4']:.2f}\"\n\n    if 'invrate0' in params:\n        title += f\", P_r={params['invrate0']}, P_s={params['invrate1']}, P_p={params['invrate2']}\"\n    if 'invrate3' in params and params['invrate3'] &gt; 0:\n        title += f\", P_u={params['invrate3']}\"\n    if 'invrate4' in params and params['invrate4'] &gt; 0:\n        title += f\", P_v={params['invrate4']}\"\n\n    if 'swap_exp' in params:\n        title += f\", swap\\_exp={params['swap_exp']}, reproduce\\_exp={params['reproduce_exp']}, select\\_exp={params['select_exp']}\"\n\n    if steps:\n        title += f\", step={steps}$\"\n    else:\n        title += \"$\"\n    \n    return title\n\n\nPlotting the evolution of the system (replicating Figure 2a from [1]):\n\n\nCode\nternary_plot_species_evolution(results_df, title=build_title(params=model_params1))\n\n\n\n\n\nUnlike the long-range dispersal model, where in the same setting the weakest species outcompetes the others, here the dynamics stabilize, and the population densities converge towards the fixed point.\nLet’s define the parameters to perform a simulation of a system with \\(3\\) species, on a square lattice with \\(N=200\\cdot 200\\) sites and equal invasion rates (\\(Pr_=0.33, P_s=0.33, P_p=0.33\\)). The grid will be initialized with the sites being randomly assigned to each of the three species in fixed-point proportions (\\(n_r=0.33, n_s=0.33, n_p=0.33\\)).\n\n\nCode\nmodel_params2 = {\n    \"height\": 200,\n    \"width\": 200,\n    \"n_species\": 3,\n    \"init0\": 0.33,\n    \"init1\": 0.33,\n    \"init2\": 0.33,\n    \"init3\": 0,\n    \"init4\": 0,\n    \"invrate0\": 0.33,\n    \"invrate1\": 0.33,\n    \"invrate2\": 0.33,\n    \"invrate3\": 0,\n    \"invrate4\": 0,\n    \"color_map\": color_map\n}\n\n\nCreating the widget to interactively simulate the system:\n\n\nCode\npage = JupyterViz(\n    RSPRandAct,\n    model_params2,\n    measures=[line_plot],\n    agent_portrayal=agent_portrayal,\n)\npage\n\n\n\n\n\nRunning a simulation and plotting the grid after \\(100\\) steps (replicating Figure 2b from [1]) and the evolution of the species proportions over time:\n\n\nCode\nmodel2 = run_model(model_class=RSPRandAct, params=model_params2, steps=100)\n\n\n\n\nCode\ndraw_grid(\n    model2.grid,\n    agent_portrayal,\n    title=build_title(params=model_params2, steps=100)\n)\n\n\n\n\n\n\n\nCode\nline_plot(\n    model2,\n    title=build_title(params=model_params2)\n)\n\n\n\n\n\nWith equal invasion rates, the populations form clumps.\nLet’s define the parameters to perform a simulation of a system with \\(3\\) species, on a square lattice with \\(N=200\\cdot 200\\) sites and invasion rates \\(P_r=0.1, P_s=0.1, P_p=0.8\\). The grid is initialized with the sites being randomly assigned to each of the three species in fixed-point proportions (\\(n_r=0.1, n_s=0.8, n_p=0.1\\)).\n\n\nCode\nmodel_params3 = {\n    \"height\": 200,\n    \"width\": 200,\n    \"color_map\": color_map,\n    \"n_species\": 3,\n    \"init0\": 0.1,\n    \"init1\": 0.8,\n    \"init2\": 0.1,\n    \"init3\": 0,\n    \"init4\": 0,\n    \"invrate0\": 0.1,\n    \"invrate1\": 0.1,\n    \"invrate2\": 0.8,\n    \"invrate3\": 0,\n    \"invrate4\": 0,\n}\n\n\nCreating the widget to interactively simulate the system:\n\n\nCode\npage = JupyterViz(\n    RSPRandAct,\n    model_params3,\n    measures=[line_plot],\n    agent_portrayal=agent_portrayal,\n)\npage\n\n\n\n\n\nRunning a simulation and plotting the grid after \\(100\\) steps (replicating Figure 2c from [1]) and the evolution of the species proportions over time:\n\n\nCode\nmodel3 = run_model(model_class=RSPRandAct, params=model_params3, steps=100)\n\n\n\n\nCode\ndraw_grid(\n    model3.grid,\n    agent_portrayal,\n    title=build_title(params=model_params3, steps=100)\n)\n\n\n\n\n\n\n\nCode\nline_plot(\n    model3,\n    title=build_title(params=model_params3)\n)\n\n\n\n\n\nWhen species \\(S\\) invasion rates is much larger than the other two, species \\(R\\) and \\(P\\) form disconnected islands amongst species \\(S\\).\nLet’s define the parameters to perform a simulation of a system with \\(3\\) species, on a square lattice with \\(N=200\\cdot 200\\) sites and invasion rates \\(P_r=0.05, P_s=0.475, P_p=0.475\\). The grid is initialized with the sites being randomly assigned to each of the three species in fixed-point proportions (\\(n_r=0.475, n_s=0.475, n_p=0.05\\)).\n\n\nCode\nmodel_params4 = {\n    \"height\": 200,\n    \"width\": 200,\n    \"color_map\": color_map,\n    \"n_species\": 3,\n    \"init0\": 0.475,\n    \"init1\": 0.475,\n    \"init2\": 0.05,\n    \"init3\": 0,\n    \"init4\": 0,\n    \"invrate0\": 0.05,\n    \"invrate1\": 0.475,\n    \"invrate2\": 0.475,\n    \"invrate3\": 0,\n    \"invrate4\": 0,\n}\n\n\nCreating the widget to interactively simulate the system:\n\n\nCode\npage = JupyterViz(\n    RSPRandAct,\n    model_params4,\n    measures=[line_plot],\n    agent_portrayal=agent_portrayal,\n)\npage\n\n\n\n\n\nRunning a simulation and plotting the grid after \\(100\\) steps (replicating Figure 2d from [1]) and the evolution of the species proportions over time:\n\n\nCode\nmodel4_100 = run_model(model_class=RSPRandAct, params=model_params4, steps=100)\n\n\n\n\nCode\ndraw_grid(\n    model4_100.grid,\n    agent_portrayal,\n    title=build_title(params=model_params4, steps=100)\n    )\n\n\n\n\n\n\n\nCode\nline_plot(\n    model4_100,\n    title=build_title(params=model_params4)\n)\n\n\n\n\n\nRunning a simulation and plotting the grid after \\(300\\) steps (replicating Figure 2d from [1]) and the evolution of the species proportions over time.\n\n\nCode\nmodel4_300 = run_model(model_class=RSPRandAct, params=model_params4, steps=300)\n\n\n\n\nCode\ndraw_grid(\n    model4_300.grid,\n    agent_portrayal,\n    title=build_title(params=model_params4, steps=300)\n    )\n\n\n\n\n\n\n\nCode\nline_plot(\n    model4_300,\n    title=build_title(params=model_params4)\n)\n\n\n\n\n\nIf species \\(R\\) invasion rate is much smaller than the other two, then species \\(R\\) and \\(S\\) have similar patchy distributions, with species \\(P\\) persisting in fast-moving thin fronts.\nDefining the parameters to perform simulations for a range of invasion probabilities chosen to sum to unity, initializing the population densities with equal proportions:\n\n\nCode\n# defining a grid of points for invasion probabilities\nR, S = np.mgrid[0:1:10j, 0:1:10j]\nR, S = R.ravel(), S.ravel()\nP = 1 - R - S\nI = np.array([R, S, P]).T\n# keeping only invasion probabilities greater than 0.01\nI = I[np.all(I &gt; 0.01, axis=1)]\nR = I[:, 0]\nS = I[:, 1]\nP = I[:, 2]\n# parameters for the batch run\nparams_batch = {\n    \"height\": 100,\n    \"width\": 100,\n    \"color_map\": color_map,\n    \"n_species\": 3,\n    \"init0\": 0.33,\n    \"init1\": 0.33,\n    \"init2\": 0.33,\n    \"init3\": 0,\n    \"init4\": 0,\n    \"invrate3\": 0,\n    \"invrate4\": 0,\n}\n\n\nSetting a macro to actually run the simulations or load the results of the already executed simulations from a file (executing the simulations may take a long time):\n\n\nCode\nEXECUTE = False\n\n\nPerforming simulations:\n\n\nCode\nif EXECUTE:\n    # dataframe to store the results\n    batch_results_df = pd.DataFrame()\n\n    # iterating over the invasion probabilities\n    for i, (Pr, Ps, Pp) in enumerate(I):\n        params_batch['invrate0'] = Pr\n        params_batch['invrate1'] = Ps\n        params_batch['invrate2'] = Pp\n        print(f\"[{i+1}/{len(I)}] Running model with parameters: {params_batch}\")\n        # simulating with the current invasion probabilities\n        results = mesa.batch_run(\n            RSPRandAct,\n            params_batch,\n            iterations=1,\n            max_steps=300,\n            number_processes=1,\n            data_collection_period=1,\n            display_progress=True,\n        )\n        # concatenating the results of the current simulation\n        curr_results_df = pd.DataFrame(results)\n        curr_results_df['simulation_id'] = i\n        tot_individuals = curr_results_df[0] + curr_results_df[1] + curr_results_df[2]\n        curr_results_df.rename(columns={0: 'individuals_r', 1: 'individuals_s', 2: 'individuals_p'}, inplace=True)\n        curr_results_df['$n_r$'] = curr_results_df['individuals_r'] / tot_individuals\n        curr_results_df['$n_s$'] = curr_results_df['individuals_s'] / tot_individuals\n        curr_results_df['$n_p$'] = curr_results_df['individuals_p'] / tot_individuals\n        batch_results_df = pd.concat([batch_results_df, curr_results_df])\n\n    # saving the results to a csv file\n    batch_results_df.to_csv(\"../results/lattice_simulations_results.csv\", index=False)\nelse:\n    batch_results_df = pd.read_csv(\"../results/lattice_simulations_results.csv\")\n\n\nPlotting contours summarizing the results of \\(28\\) simulations that are each \\(300\\) epochs long on a square lattice with \\(N=100\\cdot 100\\) sites and showing the mean value of \\(n_s\\) over the final \\(100\\) epochs of each model run (replicating Figure 2e from [1]). Data are only shown for the region that had all its invasion probabilities greater than \\(0.01\\) as outside this region, with such a small invasion probability, the grid is too small to stabilize fluctuations in the population densities.\n\n\nCode\nns_final = np.array(batch_results_df[batch_results_df['Step']&gt;200].groupby('simulation_id')['$n_s$'].mean())\nfig = ff.create_ternary_contour(\n    np.array([I.T[2], I.T[1], I.T[0]]),\n    ns_final,\n    pole_labels=['$P_p$', '$P_s$', '$P_r$'],\n    interp_mode='ilr',\n    ncontours=15,\n    colorscale='Portland',\n    coloring=None,\n    showmarkers=True,\n    showscale=True,\n    title=r'$\\text{Mean value of }n_s\\text{ over the final 100 steps of each simulation}\\\\\\text{(population densities initialized with equal proportions)}$',\n)\nfig.update_layout(width=600)\nfig.show('png')\n\n\n\n\n\nThe value of \\(n_s\\) after \\(300\\) epochs varies linearly from the base of the triangle to the top. Deviations from the mean-field approximation are seen toward the corners of the triangle.\nDespite the large clumps that may develop when the invasion rates are unequal, the population densities remain close to the fixed point of the mean-field equations (\\(S=\\frac{P_p}{P_p+P_r+P_s}=P_p\\)) over much of the parameter space of the invasion probabilities (the values of \\(n_s\\) are close to the values of \\(P_p\\)). The paradox that the most aggressive species does not have the largest population still holds (when \\(P_p\\) is the largest, \\(n_s\\) is the largest).\nLet’s define the parameters to perform a simulation of a system with \\(3\\) species in which the invasion rate of a species (species \\(R\\)) is increased over time (increase_rate=True), on a square lattice with \\(N=200\\cdot 200\\) sites and initial invasion rates \\(P_r=0.05, P_s=0.5, P_p=0.3\\). The grid is initialized with the sites being randomly assigned to each of the three species in fixed-point proportions (\\(n_r=0.5, n_s=0.3, n_p=0.05\\)).\n\n\nCode\nmodel_params5 = {\n    \"height\": 200,\n    \"width\": 200,\n    \"color_map\": color_map,\n    \"n_species\": 3,\n    \"init0\": 0.5,\n    \"init1\": 0.3,\n    \"init2\": 0.05,\n    \"init3\": 0,\n    \"init4\": 0,\n    \"invrate0\": 0.05,\n    \"invrate1\": 0.5,\n    \"invrate2\": 0.3,\n    \"invrate3\": 0,\n    \"invrate4\": 0,\n    \"increase_rate\": True\n}\n\n\nCreating the widget to interactively simulate the system:\n\n\nCode\npage = JupyterViz(\n    RSPRandAct,\n    model_params5,\n    measures=[line_plot, plot_rate_species0],\n    agent_portrayal=agent_portrayal,\n)\npage\n\n\n\n\n\nRunning a simulation and plotting the evolution of the species proportions over time and the evolution of the invasion rate of species \\(R\\) (replicating a scenario similar to that analyzed in Figure 3 of [1]):\n\n\nCode\nmodel5 = run_model(model_class=RSPRandAct, params=model_params5, steps=400)\n\n\n\n\nCode\nline_plot(\n    model5,\n    title=build_title(params=model_params5)\n)\n\n\n\n\n\n\n\nCode\nplot_rate_species0(\n    model5,\n    title=build_title(params=model_params5)\n)\n\n\n\n\n\nAn increase in the invasion rate of species \\(R\\) results in a decrease of its population. Evolution tends to favor the most competitive individuals within a species, which paradoxically causes a decline in its overall population, ultimately supporting the maintenance of diversity."
  },
  {
    "objectID": "notebooks/lattice_simulations.html#model-with-simultaneous-activation-of-agents",
    "href": "notebooks/lattice_simulations.html#model-with-simultaneous-activation-of-agents",
    "title": "Lattice model",
    "section": "2. Model with simultaneous activation of agents",
    "text": "2. Model with simultaneous activation of agents\nThis is a variant of the model where the \\(N\\) sites are again taken to be sites in a periodic, rectangular lattice, but at each time step, all agents are activated simultaneously. During each activation, each agent competes with all its neighboring agents. In a three species system, if an agent is surrounded by at least three neighbors of a species that defeats it, the agent is converted into an individual of that species. Please note that invasion rates are not used in this model.\n\n2.1. Implementation details\nThe model is defined by the class RSPSimAct in the file ../lattice_models/model_sim_act.py:\n\n\nCode\n%pycat ../lattice_models/model_sim_act.py\n\n\nimport mesa\nfrom .patch_sim_act import PatchSimAct\nfrom mesa.datacollection import DataCollector\n\nclass RSPSimAct(mesa.Model):\n    \"\"\"\n    A system with three species in a competitive loop: a rock beats a pair of scissors,\n    scissors beat a sheet of paper and paper beats a rock.\n    \"\"\"\n\n    rules3 = {0: [1], 1: [2], 2: [0]}\n    rules4 = {0: [1], 1: [2], 2: [3], 3: [0]}\n    rules5 = {0: [1,2], 1: [2,3], 2: [3,4], 3: [4,0], 4: [0,1]}\n\n    def __init__(self, init0, init1, init2, init3, init4, n_species, color_map, width=50, height=50):\n        \"\"\"\n        Create a new playing area of (width, height) patches.\n        \"\"\"\n        super().__init__()\n\n        self.n_species = n_species\n        self.color_map = color_map\n\n        if self.n_species == 3:\n            self.probabilities = [init0, init1, init2]\n            self.threshold = 3\n            self.rules = self.rules3\n        elif self.n_species == 4:\n            self.probabilities = [init0, init1, init2, init3]\n            self.threshold = 2\n            self.rules = self.rules4\n        else: # n_species == 5\n            self.probabilities = [init0, init1, init2, init3, init4]\n            self.threshold = 3\n            self.rules = self.rules5\n\n        # set up agent scheduler\n        self.schedule = mesa.time.SimultaneousActivation(self)\n\n        # use a simple grid, where edges wrap around.\n        self.grid = mesa.space.SingleGrid(width, height, torus=True)\n\n        # place a patch at each location, initializing it as ROCK, SCISSOR, or PAPER\n        for _, (x, y) in self.grid.coord_iter():\n            patch_init_state = self.random.choices(range(self.n_species), weights=self.probabilities, k=1)[0]\n            patch = PatchSimAct(pos=(x, y), model=self, init_state=patch_init_state)\n            self.grid.place_agent(patch, (x, y))\n            self.schedule.add(patch)\n\n        self.running = True\n        \n        # collect data\n        model_reporter = {}\n        for i in range(self.n_species):\n            model_reporter[i] = lambda model, species=i: model.count_patches(species)\n        self.datacollector = DataCollector(\n            model_reporter\n        )\n        self.datacollector.collect(self)\n\n    def count_patches(self, species):\n        \"\"\"\n        Helper method to count the number of patches in the given state.\n        \"\"\"\n        return sum([1 for patch in self.schedule.agents if patch.state == species])\n\n    def step(self):\n        \"\"\"\n        Have the scheduler advance each patch by one step.\n        \"\"\"\n        self.schedule.step()\n        self.datacollector.collect(self)\n\n        n_existint_species = sum([1 for i in range(self.n_species) if self.count_patches(i) == 0])\n        if n_existint_species == self.n_species-1:\n            self.running = False\n\n\n\nThe model can be simulated with \\(3\\), \\(4\\), or \\(5\\) species. When there are \\(4\\) species, species \\(&lt;1,3&gt;\\) and \\(&lt;2,4&gt;\\) do not compete with each other.\nSimultaneous activation of agents is implemented through the mesa.time.SimultaneousActivation scheduler.\nAgents are situated on a rectangular, periodic grid (i.e. torus), where each cell contains exactly at most one agent. Such a grid is created by the mesa.space.SingleGrid class.\nThe grid is randomly initialized by placing agents in each cell according to the initial proportions of the species (the parameters init* are used as weights in the random.choices function).\n\nThe behavior of each agent (grid patch) is defined by the class PatchSimAct in the file ../lattice_models/patch_sim_act.py:\n\n\nCode\n%pycat ../lattice_models/patch_sim_act.py\n\n\nimport mesa\nimport numpy as np\n\nclass PatchSimAct(mesa.Agent):\n    \"\"\"Represents a single patch in the simulation.\"\"\"\n\n    def __init__(self, pos, model, init_state):\n        \"\"\"\n        Create a patch, in the given state, at the given x, y position.\n        \"\"\"\n        super().__init__(pos, model)\n        self.rules = model.rules\n        self.n_species = model.n_species\n        self.color_map = model.color_map\n        self.threshold = model.threshold\n        self.x, self.y = pos\n        self.state = init_state\n        self._nextState = None\n\n    def step(self):\n        \"\"\"\n        Compute the next state of the path according to the rules of the game and\n        the number of defeats of each type.\n        The state is not changed here, but is just computed and stored in self._nextState,\n        because our current state may still be necessary for our neighbors\n        to calculate their next state.\n        \"\"\"\n\n        # assume nextState is unchanged, unless changed below\n        self._nextState = self.state\n\n        # get the neighbors\n        neighbors = self.model.grid.get_neighbors((self.x, self.y), moore=True)\n\n        # count the number of defeats of each type\n        defeat_counts = np.zeros(self.n_species)\n        for neighbor in neighbors:\n            if neighbor.state != self.state and self.state in self.rules[neighbor.state]:\n                defeat_counts[neighbor.state] += 1\n        \n        # compute the winning species\n        winners = np.argwhere(defeat_counts == np.max(defeat_counts)).reshape(-1)\n        self.random.shuffle(winners)\n        for i in range(len(winners)):\n            if defeat_counts[winners[i]] &gt;= self.threshold:\n                self._nextState = winners[i]\n                break\n\n    def advance(self):\n        \"\"\"\n        Set the state to the new state, computed in the method step().\n        \"\"\"\n        self.state = self._nextState\n\n\n\nEach patch has a Moore neighborhood, i.e. the eight cells surrounding it.\nAt each step, an agent interacts with all its neighbors. If an agent is surrounded by at least three neighbors of the species that defeat it, it is transformed into an individual of that species. In case of a tie (possible with \\(5\\) species), the winning species is chosen randomly among the species that defeated the agent.\n\n\n\n2.2. Simulations\nLet’s define the parameters to perform a simulation of a system with \\(3\\) species, on a square lattice with \\(N=200\\cdot 200\\) sites, initialized with the sites being randomly assigned to each of the three species in equal proportions (init0=0.33, init1=0.33, init2=0.33).\n\n\nCode\nmodel_params6 = {\n    \"height\": 200,\n    \"width\": 200,\n    \"n_species\": 3,\n    \"init0\": 0.33,\n    \"init1\": 0.33,\n    \"init2\": 0.33,\n    \"init3\": 0,\n    \"init4\": 0,\n    \"color_map\": color_map\n}\n\n\nCreating the widget to interactively simulate the system:\n\n\nCode\npage = JupyterViz(\n    RSPSimAct,\n    model_params6,\n    measures=[line_plot],\n    agent_portrayal=agent_portrayal,\n)\npage\n\n\n\n\n\nRunning a simulation and plotting the grid after \\(200\\) steps and the evolution of the species proportions over time:\n\n\nCode\nmodel6 = run_model(model_class=RSPSimAct, params=model_params6, steps=200)\n\n\n\n\nCode\ndraw_grid(\n    model6.grid,\n    agent_portrayal,\n    title=build_title(params=model_params6, steps=200)\n)\n\n\n\n\n\n\n\nCode\nline_plot(\n    model6,\n    title=build_title(params=model_params6)\n)\n\n\n\n\n\n\n\nCode\nresults_df = model6.datacollector.get_model_vars_dataframe().rename(columns={0: '$n_r$', 1: '$n_s$', 2: '$n_p$'})\nternary_plot_species_evolution(results_df, title=build_title(params=model_params6))\n\n\n\n\n\nThe system dynamics lead to the formation of a spiraling pattern, with population densities remaining roughly equal.\nLet’s define the parameters to perform a simulation of a system with \\(3\\) species, on a square lattice with \\(N=200\\cdot 200\\) sites, initialized with the sites being randomly assigned to each of the three species according to the following probabilities init0=0.2, init1=0.4, init2=0.4.\n\n\nCode\nmodel_params7 = {\n    \"height\": 200,\n    \"width\": 200,\n    \"n_species\": 3,\n    \"init0\": 0.2,\n    \"init1\": 0.4,\n    \"init2\": 0.4,\n    \"init3\": 0,\n    \"init4\": 0,\n    \"color_map\": color_map\n}\n\n\nCreating the widget to interactively simulate the system:\n\n\nCode\npage = JupyterViz(\n    RSPSimAct,\n    model_params7,\n    measures=[line_plot],\n    agent_portrayal=agent_portrayal,\n)\npage\n\n\n\n\n\nRunning a simulation and plotting the grid after \\(400\\) steps and the evolution of the species proportions over time:\n\n\nCode\nmodel7 = run_model(model_class=RSPSimAct, params=model_params7, steps=400)\n\n\n\n\nCode\ndraw_grid(\n    model7.grid,\n    agent_portrayal,\n    title=build_title(params=model_params7, steps=400)\n)\n\n\n\n\n\n\n\nCode\nline_plot(\n    model7,\n    title=build_title(params=model_params7)\n)\n\n\n\n\n\n\n\nCode\nresults_df = model7.datacollector.get_model_vars_dataframe().rename(columns={0: '$n_r$', 1: '$n_s$', 2: '$n_p$'})\nternary_plot_species_evolution(results_df, title=build_title(params=model_params7))\n\n\n\n\n\nThe system eventually stabilizes at a fixed point with equal population densities, resulting in the formation of intricate octagonal patterns.\nLet’s define the parameters to perform a simulation of a system with \\(3\\) species, on a square lattice with \\(N=200\\cdot 200\\) sites, initialized with the sites being randomly assigned to each of the three species according to the following probabilities init0=0.1, init1=0.3, init2=0.5.\n\n\nCode\nmodel_params8 = {\n    \"height\": 200,\n    \"width\": 200,\n    \"n_species\": 3,\n    \"init0\": 0.1,\n    \"init1\": 0.3,\n    \"init2\": 0.5,\n    \"init3\": 0,\n    \"init4\": 0,\n    \"color_map\": color_map\n}\n\n\nCreating the widget to interactively simulate the system:\n\n\nCode\npage = JupyterViz(\n    RSPSimAct,\n    model_params8,\n    measures=[line_plot],\n    agent_portrayal=agent_portrayal,\n)\npage\n\n\n\n\n\nRunning a simulation and plotting the evolution of the species proportions during \\(100\\) steps:\n\n\nCode\nmodel8 = run_model(model_class=RSPSimAct, params=model_params8, steps=100)\n\n\n\n\nCode\nline_plot(\n    model8,\n    title=build_title(params=model_params8)\n)\n\n\n\n\n\nThis time the species with lower initial population density (species \\(R\\)) dominates the system and the other two species go extinct.\nLet’s define the parameters to perform a simulation of a system with \\(4\\) species, on a square lattice with \\(N=200\\cdot 200\\) sites, initialized with the sites being randomly assigned to each of the three species in equal proportions (init0=0.25, init1=0.25, init2=0.25, init3=0.25, init4=0).\n\n\nCode\nmodel_params9 = {\n    \"height\": 200,\n    \"width\": 200,\n    \"n_species\": 4,\n    \"init0\": 0.25,\n    \"init1\": 0.25,\n    \"init2\": 0.25,\n    \"init3\": 0.25,\n    \"init4\": 0,\n    \"color_map\": {\n        0: 'red',\n        1: 'purple',\n        2: 'gold',\n        3: 'green'\n    }\n}\n\n\nCreating the widget to interactively simulate the system:\n\n\nCode\npage = JupyterViz(\n    RSPSimAct,\n    model_params9,\n    measures=[line_plot],\n    agent_portrayal=agent_portrayal,\n)\npage\n\n\n\n\n\nRunning a simulation and plotting the grid after \\(200\\) steps and the evolution of the species proportions over time:\n\n\nCode\nmodel9 = run_model(model_class=RSPSimAct, params=model_params9, steps=200)\n\n\n\n\nCode\ndraw_grid(\n    model9.grid,\n    agent_portrayal,\n    title=build_title(params=model_params9, steps=200)\n)\n\n\n\n\n\n\n\nCode\nline_plot(\n    model9,\n    title=build_title(params=model_params9)\n)\n\n\n\n\n\nWith \\(4\\) species, initially distributed in equal proportions, the system dynamics stabilize and regular spiral patterns emerge.\nLet’s define the parameters to perform a simulation of a system with \\(5\\) species, on a square lattice with \\(N=200\\cdot 200\\) sites, initialized with the sites being randomly assigned to each of the three species in equal proportions (init0=0.2, init1=0.2, init2=0.2, init3=0.2, init4=0.2).\n\n\nCode\nmodel_params10 = {\n    \"height\": 200,\n    \"width\": 200,\n    \"n_species\": 5,\n    \"init0\": 0.2,\n    \"init1\": 0.2,\n    \"init2\": 0.2,\n    \"init3\": 0.2,\n    \"init4\": 0.2,\n    \"color_map\": {\n        0: 'red',\n        1: 'purple',\n        2: 'gold',\n        3: 'green',\n        4: 'blue',\n    }\n}\n\n\nCreating the widget to interactively simulate the system:\n\n\nCode\npage = JupyterViz(\n    RSPSimAct,\n    model_params10,\n    measures=[line_plot],\n    agent_portrayal=agent_portrayal,\n)\npage\n\n\n\n\n\nRunning a simulation and plotting the grid after \\(100\\) steps and the evolution of the species proportions over time:\n\n\nCode\nmodel10 = run_model(model_class=RSPSimAct, params=model_params10, steps=100)\n\n\n\n\nCode\ndraw_grid(\n    model10.grid,\n    agent_portrayal,\n    title=build_title(params=model_params10, steps=100)\n)\n\n\n\n\n\n\n\nCode\nline_plot(\n    model10,\n    title=build_title(params=model_params10)\n)\n\n\n\n\n\nWith \\(5\\) species, initially distributed in equal proportions, again the system dynamics lead to the formation of a spiral pattern."
  },
  {
    "objectID": "notebooks/lattice_simulations.html#reichenbach-mobilia-and-frey-model",
    "href": "notebooks/lattice_simulations.html#reichenbach-mobilia-and-frey-model",
    "title": "Lattice model",
    "section": "3. Reichenbach, Mobilia and Frey model",
    "text": "3. Reichenbach, Mobilia and Frey model\nIn this model the \\(N\\) sites are taken to be sites in a periodic, rectangular lattice. Each patch can be occupied by one of the species or can be blank. Each tick, the following types of events happen at defined average rates: - Select event: Two random neighbors compete with each other. The losing patch becomes blanks. - Reproduce event: Two random neighbors attempt to reproduce. If one of the neighbors is blank, it acquires the color of the other. Nothing happens if neither neighbor is blank. - Swap event: Two random neighbors swap color. This represents the organisms moving on the lattice.\nTherefore, this model combines the local competition and reproduction from the Frean and Abraham model [1] with spatial migration, a ubiquitous feature of real ecosystems. For more details, see the original paper [2] and the NetLogo model [3].\nThe exact number of, for instance, swap events that occur each tick is drawn from a Poisson distribution with mean equal to \\((number\\_ of\\_ patches) * 10 ^{swap-exponent}\\). A Poisson distribution defines how many times a particular event occurs given an average rate for that event assuming that the occurrences of that event are independent. Here, the occurrences of the events are approximately independent since they’re being performed by different organisms. The events occur in a random order involving random pairs of neighbors.\n\n3.1. Implementation details\nThe model is defined by the class RSPMobility in the file ../lattice_models/model_mobility.py:\n\n\nCode\n%pycat ../lattice_models/model_mobility.py\n\n\nimport mesa\nimport numpy as np\nfrom .patch_mobility import PatchMobility\nfrom mesa.datacollection import DataCollector\n\nclass RSPMobility(mesa.Model):\n    \"\"\"\n    Represents the 2-dimensional array of patches in Rock-Scissors-Paper Game.\n    \"\"\"\n\n    rules3 = {1: [2], 2: [3], 3: [1]}\n    rules4 = {1: [2], 2: [3], 3: [4], 4: [1]}\n    rules5 = {1: [2,3], 2: [3,4], 3: [4,5], 4: [5,1], 5: [1,2]}\n\n    def __init__(\n            self,\n            init0, init1, init2, init3, init4, init5,\n            swap_exp, reproduce_exp, select_exp,\n            n_species, color_map, width=50, height=50\n        ):\n        \"\"\"\n        Create a new playing area of (width, height) patches.\n        \"\"\"\n        super().__init__()\n\n        self.n_species = n_species\n\n        event_repetitions = (width * height) // 3\n        self.expected_swap = (10**swap_exp)*event_repetitions\n        self.expected_reproduce = (10**reproduce_exp)*event_repetitions\n        self.expected_select = (10**select_exp)*event_repetitions\n\n        self.color_map = color_map\n\n        if self.n_species == 3:\n            self.probabilities = [init0, init1, init2, init3]\n            self.rules = self.rules3\n        elif self.n_species == 4:\n            self.probabilities = [init0, init1, init2, init3, init4]\n            self.rules = self.rules4\n        else: # n_species == 5\n            self.probabilities = [init0, init1, init2, init3, init4, init5]\n            self.rules = self.rules5\n\n        # Set up the grid and schedule.\n\n        self.schedule = mesa.time.RandomActivation(self)\n\n        # Use a simple grid, where edges wrap around.\n        self.grid = mesa.space.SingleGrid(width, height, torus=True)\n\n        # Place a patch at each location, initializing it as ROCK, SCISSOR, or PAPER\n        for _, (x, y) in self.grid.coord_iter():\n            patch_init_state = self.random.choices(range(0, self.n_species+1), weights=self.probabilities, k=1)[0]\n            patch = PatchMobility(pos=(x, y), model=self, init_state=patch_init_state)\n            self.grid.place_agent(patch, (x, y))\n            self.schedule.add(patch)\n\n        self.running = True\n        \n        model_reporter = {}\n        for i in range(self.n_species+1):\n            model_reporter[i] = lambda model, species=i: model.count_patches(species)\n        \n        self.datacollector = DataCollector(\n            model_reporter\n        )\n        self.datacollector.collect(self)\n\n    def count_patches(self, species):\n        \"\"\"\n        Helper method to count the number of patches in the given state.\n        \"\"\"\n        return sum([1 for patch in self.schedule.agents if patch.state == species])\n\n    def step(self):\n        \"\"\"\n        Compute the number of global events and have the scheduler advance each\n        patch by one step.\n        \"\"\"\n\n        # create a list of events with random Poisson distribution\n        self.events = []\n        self.events.extend(['swap'] * int(np.random.poisson(self.expected_swap)))\n        self.events.extend(['reproduce'] * int(np.random.poisson(self.expected_reproduce)))\n        self.events.extend(['select'] * int(np.random.poisson(self.expected_select)))\n        \n        # shuffle events\n        self.random.shuffle(self.events)\n\n        self.schedule.step()\n        self.datacollector.collect(self)\n\n        n_existint_species = sum([1 for i in range(1, self.n_species+1) if self.count_patches(i) == 0])\n        if n_existint_species == self.n_species-1:\n            self.running = False\n\n\n\nThe model can be simulated with \\(3\\), \\(4\\), or \\(5\\) species. init0 represents the initial proportion of empty patches. When there are \\(4\\) species, species \\(&lt;1,3&gt;\\) and \\(&lt;2,4&gt;\\) do not compete with each other.\nEach agent is activated once per step, in random order, with the order reshuffled each step, through the mesa.time.RandomActivation scheduler.\nAgents are situated on a rectangular, periodic grid (i.e. torus), where each cell contains exactly at most one agent. Such a grid is created by the mesa.space.SingleGrid class.\nThe grid is randomly initialized by placing agents in each cell according to the initial proportions of the species (the parameters init* are used as weights in the random.choice function).\nThis model uses an event-based approach. It calculates how many events of each type should occur each tick and then makes agents execute those events in a random order. Hence, this code creates a list with an entry for each event type that should occur each tick and then shuffles that list so that the events are in a random order. Agents are randomly activated sequentially, and each agent pops an event off the list and, together with a random neighboring patch, runs the corresponding event.\n\nThe behavior of each agent (grid patch) is defined by the class PatchMobility in the file ../lattice_models/patch_mobility.py:\n\n\nCode\n%pycat ../lattice_models/patch_mobility.py\n\n\nimport mesa\n\nclass PatchMobility(mesa.Agent):\n    \"\"\"Represents a single patch in the simulation.\"\"\"\n\n    def __init__(self, pos, model, init_state):\n        \"\"\"\n        Create a patch, in the given state, at the given x, y position.\n        \"\"\"\n        super().__init__(pos, model)\n        self.rules = model.rules\n        self.n_species = model.n_species\n        self.color_map = model.color_map\n        self.x, self.y = pos\n        self.state = init_state\n        self._nextState = None\n\n    def step(self):\n        \"\"\"\n        Compute the next state of the patch and/or of a randomly chosen\n        neighbor, according to the event that is going to happen.\n        \"\"\"\n        # Get the neighbors\n        neighbors = self.model.grid.get_neighbors((self.x, self.y), moore=False) # 4 neighbors\n\n        # get the action\n        if len(self.model.events) == 0:\n            return\n        action = self.model.events.pop(0)\n\n        # select a random neighbor\n        neighbor = self.random.choice(neighbors)\n\n        # act\n        if action == 'swap':\n            self._nextState = neighbor.state\n            neighbor.state = self.state\n            self.state = self._nextState\n        elif action == 'select':\n            if neighbor.state != 0 and self.state in self.rules[neighbor.state]:\n                self.state = 0\n            if self.state != 0 and neighbor.state in self.rules[self.state]:\n                neighbor.state = 0\n        else:\n            if neighbor.state == 0:\n                neighbor.state = self.state\n            elif self.state == 0:\n                self.state = neighbor.state\n\n\n\nEach patch has a Von Neumann neighborhood, i.e. the four cells surrounding it.\nAgent state 0 represents an empty patch.\nAt each step, a neighbor is randomly chosen and the agent in the patch interacts with it, according to the event type.\n\nDefining a function to compute the percentage of each event type at each step:\n\n\nCode\ndef compute_mobility_perc(params):\n    total = 10**(params['swap_exp']) + 10**(params['reproduce_exp']) + 10**(params['select_exp'])\n    print(f\"Swap %: {100*(10**(params['swap_exp'])) / total:.2f}\")\n    print(f\"Reproduce %: {100*(10**(params['reproduce_exp'])) / total:.2f}\")\n    print(f\"Select %: {100*(10**(params['select_exp'])) / total:.2f}\")\n\n\n\n\n3.2. Simulations\nLet’s define the parameters to perform a simulation of a system with \\(3\\) species, on a square lattice with \\(N=150\\cdot 150\\) sites, initialized with the sites being randomly assigned to each of the three species and empty sites in equal proportions (init0=0.25, init1=0.25, init2=0.25, init3=0.25). Black patches represent empty sites.\n\n\nCode\ncolor_map_mobility = {\n    0: 'black',\n    1: 'red',\n    2: 'purple',\n    3: 'gold'\n}\nmodel_params_mobility = {\n    \"height\": 150,\n    \"width\": 150,\n    \"n_species\": 3,\n    \"init0\": 0.25,\n    \"init1\": 0.25,\n    \"init2\": 0.25,\n    \"init3\": 0.25,\n    \"init4\": 0,\n    \"init5\": 0,\n    \"color_map\": color_map_mobility\n}\n\n\nWe will run simulations setting swap exponent to \\(-1\\), \\(0\\), \\(0.5\\) and \\(1\\) and fixing reproduce and select exponents to \\(0\\).\nSetting parameters and computing the percentage of each event type at each step:\n\n\nCode\nmodel_params11 = model_params_mobility.copy()\nmodel_params11['swap_exp'] = -1\nmodel_params11['reproduce_exp'] = 0\nmodel_params11['select_exp'] = 0\nprint(\"Configuration 1\")\ncompute_mobility_perc(model_params11)\nprint(\"----------------\")\n\nmodel_params12 = model_params_mobility.copy()\nmodel_params12['swap_exp'] = 0\nmodel_params12['reproduce_exp'] = 0\nmodel_params12['select_exp'] = 0\nprint(\"Configuration 2\")\ncompute_mobility_perc(model_params12)\nprint(\"----------------\")\n\nmodel_params13 = model_params_mobility.copy()\nmodel_params13['swap_exp'] = 0.5\nmodel_params13['reproduce_exp'] = 0\nmodel_params13['select_exp'] = 0\nprint(\"Configuration 3\")\ncompute_mobility_perc(model_params13)\nprint(\"----------------\")\n\nmodel_params14 = model_params_mobility.copy()\nmodel_params14['swap_exp'] = 1\nmodel_params14['reproduce_exp'] = 0\nmodel_params14['select_exp'] = 0\nprint(\"Configuration 4\")\ncompute_mobility_perc(model_params14)\nprint(\"----------------\")\n\n\nConfiguration 1\nSwap %: 4.76\nReproduce %: 47.62\nSelect %: 47.62\n----------------\nConfiguration 2\nSwap %: 33.33\nReproduce %: 33.33\nSelect %: 33.33\n----------------\nConfiguration 3\nSwap %: 61.26\nReproduce %: 19.37\nSelect %: 19.37\n----------------\nConfiguration 4\nSwap %: 83.33\nReproduce %: 8.33\nSelect %: 8.33\n----------------\n\n\nRunning simulations for \\(300\\) steps:\n\n\nCode\nmodel11 = run_model(model_class=RSPMobility, params=model_params11, steps=300)\n\n\n\n\nCode\nmodel12 = run_model(model_class=RSPMobility, params=model_params12, steps=300)\n\n\n\n\nCode\nmodel13 = run_model(model_class=RSPMobility, params=model_params13, steps=300)\n\n\n\n\nCode\nmodel14 = run_model(model_class=RSPMobility, params=model_params14, steps=300)\n\n\nVisualizing the grid after \\(300\\) steps (replicating Figure 2a from [2]):\n\n\nCode\nfig, axs = plt.subplots(2, 2, figsize=(25,15))\ndraw_grid(\n    model11.grid,\n    agent_portrayal,\n    title=build_title(params=model_params11, steps=300),\n    ax=axs[0][0]\n)\ndraw_grid(\n    model12.grid,\n    agent_portrayal,\n    title=build_title(params=model_params12, steps=300),\n    ax=axs[0][1]\n)\ndraw_grid(\n    model13.grid,\n    agent_portrayal,\n    title=build_title(params=model_params13, steps=300),\n    ax=axs[1][0]\n)\ndraw_grid(\n    model14.grid,\n    agent_portrayal,\n    title=build_title(params=model_params14, steps=300),\n    ax=axs[1][1]\n)\nfor ax in axs.flat:\n    ax.set_aspect('equal')\n\n\n\n\n\nAs in the model with simultaneous activation of agents, species self-arrange by forming patterns of moving spirals. Increasing the swap exponent (i.e. the mobility of agents), the spiral structures grow in size.\nVisualizing the evolution of the system:\n\n\nCode\nfig, axs = plt.subplots(2, 2, figsize=(25,10))\nline_plot(\n    model11,\n    title=build_title(params=model_params11),\n    ax=axs[0][0]\n)\nline_plot(\n    model12,\n    title=build_title(params=model_params12),\n    ax=axs[0][1]\n)\nline_plot(\n    model13,\n    title=build_title(params=model_params13),\n    ax=axs[1][0]\n)\nline_plot(\n    model14,\n    title=build_title(params=model_params14),\n    ax=axs[1][1]\n)\n\n\n\n\n\nIncreasing the swap exponent leads to oscillations with larger amplitudes in the population densities.\nLet’s define the parameters to perform a simulation of a system with \\(3\\) species, on a square lattice with \\(N=150\\cdot 150\\) sites, initialized with the sites being randomly assigned to each of the three species and empty sites in equal proportions (init0=0.25, init1=0.25, init2=0.25, init3=0.25), and setting the swap exponent to \\(1\\) and the reproduce and select exponents to \\(-0.7\\).\n\n\nCode\nmodel_params15 = {\n    \"height\": 100,\n    \"width\": 100,\n    \"n_species\": 3,\n    \"init0\": 0.25,\n    \"init1\": 0.25,\n    \"init2\": 0.25,\n    \"init3\": 0.25,\n    \"init4\": 0,\n    \"init5\": 0,\n    \"swap_exp\": 1,\n    \"reproduce_exp\": -0.7,\n    \"select_exp\": -0.7,\n    \"color_map\": color_map_mobility\n}\n\n\nThis corresponds to the following percentages of events at each step:\n\n\nCode\ncompute_mobility_perc(model_params15)\n\n\nSwap %: 96.16\nReproduce %: 1.92\nSelect %: 1.92\n\n\nRunning a simulation for \\(2000\\) steps:\n\n\nCode\nmodel15 = run_model(model_class=RSPMobility, params=model_params15, steps=2000)\n\n\nVisualizing the evolution of the system:\n\n\nCode\nline_plot(\n    model15,\n    title=build_title(params=model_params15)\n)\n\n\n\n\n\nWhen mobility is high, biodiversity is jeopardized and eventually lost: the system adopts a uniform state where only one species is present, while the others have died out. Which species remains is subject to a random process, all species having equal chances to survive in the model.\nLet’s define the parameters to perform a simulation of a system with \\(4\\) species, on a square lattice with \\(N=150\\cdot 150\\) sites, initialized with the sites being randomly assigned to each of the four species and empty sites in equal proportions and setting swap, reproduce and select exponents to \\(0\\).\n\n\nCode\nmodel_params16 = {\n    \"height\": 150,\n    \"width\": 150,\n    \"n_species\": 4,\n    \"init0\": 0.2,\n    \"init1\": 0.2,\n    \"init2\": 0.2,\n    \"init3\": 0.2,\n    \"init4\": 0.2,\n    \"init5\": 0,\n    \"swap_exp\": 0,\n    \"reproduce_exp\": 0,\n    \"select_exp\": 0,\n    \"color_map\": {\n        0: 'black',\n        1: 'red',\n        2: 'purple',\n        3: 'gold',\n        4: 'green'\n    }\n}\n\n\nCreating the widget to interactively simulate the system:\n\n\nCode\npage = JupyterViz(\n    RSPMobility,\n    model_params16,\n    measures=[line_plot],\n    agent_portrayal=agent_portrayal,\n)\npage\n\n\n\n\n\nRunning a simulation and plotting the grid after \\(300\\) steps and the evolution of the species proportions over time:\n\n\nCode\nmodel16 = run_model(model_class=RSPMobility, params=model_params16, steps=300)\n\n\n\n\nCode\ndraw_grid(\n    model16.grid,\n    agent_portrayal,\n    title=build_title(params=model_params16, steps=300)\n)\n\n\n\n\n\n\n\nCode\nline_plot(\n    model16,\n    title=build_title(params=model_params16)\n)\n\n\n\n\n\nWith \\(4\\) species, the system dynamics stabilize with non competing species forming islands surrounded by the other species.\nLet’s define the parameters to perform a simulation of a system with \\(5\\) species, on a square lattice with \\(N=150\\cdot 150\\) sites, initialized with the sites being randomly assigned to each of the five species and empty sites in equal proportions and setting swap, reproduce and select exponents to \\(0\\).\n\n\nCode\nmodel_params17 = {\n    \"height\": 150,\n    \"width\": 150,\n    \"n_species\": 5,\n    \"init0\": 1/6,\n    \"init1\": 1/6,\n    \"init2\": 1/6,\n    \"init3\": 1/6,\n    \"init4\": 1/6,\n    \"init5\": 1/6,\n    \"swap_exp\": 0,\n    \"reproduce_exp\": 0,\n    \"select_exp\": 0,\n    \"color_map\": {\n        0: 'black',\n        1: 'red',\n        2: 'purple',\n        3: 'gold',\n        4: 'green',\n        5: 'blue',\n    }\n}\n\n\nCreating the widget to interactively simulate the system:\n\n\nCode\npage = JupyterViz(\n    RSPMobility,\n    model_params17,\n    measures=[line_plot],\n    agent_portrayal=agent_portrayal,\n)\npage\n\n\n\n\n\nRunning a simulation and plotting the grid after \\(300\\) steps and the evolution of the species proportions over time:\n\n\nCode\nmodel17 = run_model(model_class=RSPMobility, params=model_params17, steps=300)\n\n\n\n\nCode\ndraw_grid(\n    model17.grid,\n    agent_portrayal,\n    title=build_title(params=model_params17, steps=300)\n)\n\n\n\n\n\n\n\nCode\nline_plot(\n    model17,\n    title=build_title(params=model_params17)\n)\n\n\n\n\n\nAlso with \\(5\\) species, entangled rotating spiral waves emerge."
  },
  {
    "objectID": "notebooks/lattice_simulations.html#references",
    "href": "notebooks/lattice_simulations.html#references",
    "title": "Lattice model",
    "section": "4. References",
    "text": "4. References\n\n[1] Frean, Marcus, and Edward R. Abraham. “Rock–scissors–paper and the survival of the weakest.” Proceedings of the Royal Society of London. Series B: Biological Sciences 268.1474 (2001): 1323-1327.\n[2] Reichenbach, Tobias, Mauro Mobilia, and Erwin Frey. “Mobility promotes and jeopardizes biodiversity in rock–paper–scissors games.” Nature 448.7157 (2007): 1046-1049.\n[3] Head, B., Grider, R. and Wilensky, U. (2017). NetLogo Rock Paper Scissors model. http://ccl.northwestern.edu/netlogo/models/RockPaperScissors. Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL."
  }
]